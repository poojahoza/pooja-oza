<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>Wikipedia</sitename>
    <dbname>enwiki</dbname>
    <base>https://en.wikipedia.org/wiki/Main_Page</base>
    <generator>MediaWiki 1.29.0-wmf.17</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">Wikipedia</namespace>
      <namespace key="5" case="first-letter">Wikipedia talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="100" case="first-letter">Portal</namespace>
      <namespace key="101" case="first-letter">Portal talk</namespace>
      <namespace key="108" case="first-letter">Book</namespace>
      <namespace key="109" case="first-letter">Book talk</namespace>
      <namespace key="118" case="first-letter">Draft</namespace>
      <namespace key="119" case="first-letter">Draft talk</namespace>
      <namespace key="446" case="first-letter">Education Program</namespace>
      <namespace key="447" case="first-letter">Education Program talk</namespace>
      <namespace key="710" case="first-letter">TimedText</namespace>
      <namespace key="711" case="first-letter">TimedText talk</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Module talk</namespace>
      <namespace key="2300" case="first-letter">Gadget</namespace>
      <namespace key="2301" case="first-letter">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Category:Wikipedia books on computer science</title>
    <ns>14</ns>
    <id>27537394</id>
    <revision>
      <id>545925690</id>
      <parentid>503819094</parentid>
      <timestamp>2013-03-21T08:09:13Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>6569922</id>
      </contributor>
      <minor/>
      <comment>[[User:Addbot|Bot:]] Migrating 1 interwiki links, now provided by [[Wikipedia:Wikidata|Wikidata]] on [[d:q7580294]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="222">[[Category:Wikipedia books on applied sciences|Computer science]]
[[Category:Wikipedia books on formal sciences|Computer science]]
[[Category:Wikipedia books on computing|Computer science]]
[[Category:Computer science|β]]</text>
      <sha1>gh1ge33ev4zc69uhzlurt7eemjeetjb</sha1>
    </revision>
  </page>
  <page>
    <title>Outline of computer science</title>
    <ns>0</ns>
    <id>169633</id>
    <revision>
      <id>759523718</id>
      <parentid>758629054</parentid>
      <timestamp>2017-01-11T18:05:36Z</timestamp>
      <contributor>
        <ip>183.83.253.111</ip>
      </contributor>
      <comment>/* Artificial intelligence */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10583">&lt;!--... Attention:  THIS IS AN OUTLINE

        part of the set of 700+ outlines listed at
             [[Portal:Contents/Outlines]].

                 Wikipedia outlines are
              a special type of list article.
              They make up one of Wikipedia's
                content navigation systems

                See [[Wikipedia:Outlines]]
                      for more details.
                   Further improvements
              to this outline are on the way
...--&gt;
The following [[Outline (list)|outline]] is provided as an overview of and topical guide to computer science:

'''[[Computer science]]''' (also called '''computing science''') is the study of the theoretical foundations of [[information]] and [[computation]] and their implementation and application in [[computer system]]s. One well known subject classification system for [[computer science]] is the [[ACM Computing Classification System]] devised by the [[Association for Computing Machinery]].

{{TOC limit|limit=2}}

== What ''type'' of thing is computer science? ==
Computer science can be described as all of the following:

* [[Academic discipline]]
* [[Science]]
** [[Applied science]]

== Subfields ==

=== Mathematical foundations ===

* [[Coding theory]] – Useful in networking and other areas where computers communicate with each other.
* [[Game theory]] – Useful in artificial intelligence and [[cybernetics]].
* [[Graph theory]] – Foundations for data structures and searching algorithms.
* [[Mathematical logic]] – [[Boolean logic]] and other ways of [[mathematical model|modeling]] logical queries; the uses and limitations of formal proof methods
* [[Number theory]] – Theory of the [[integer]]s.  Used in [[cryptography]] as well as a test domain in [[artificial intelligence]].

=== Algorithms and data structures ===

* [[Algorithms]] – Sequential and parallel computational procedures for solving a wide range of problems.
* [[Data structure]]s – The organization and manipulation of data.

=== Artificial intelligence ===
{{main|Outline of artificial intelligence}}
* [[Artificial intelligence]] – The implementation and study of systems that exhibit an autonomous intelligence or behavior of their own.
*  [[Automated reasoning]] – Solving engines, such as used in [[Prolog]], which produce steps to a result given a query on a fact and rule database, and [[Automated theorem proving|automated theorem provers]] that aim to prove [[mathematical theorem]]s with some assistance from a programmer.
*  [[Computer vision]] – Algorithms for identifying three-dimensional objects from a two-dimensional picture.
* [[Soft computing]], the use of inexact solutions for otherwise extremely difficult problems:
** [[Machine learning]] - Automated creation of a set of rules and axioms based on input.
** [[Evolutionary computing]] - Biologically inspired algorithms.
*  [[Natural language processing]] - Building systems and algorithms that analyze, understand, and generate natural (human) languages.
*  [[Robotics]] – Algorithms for controlling the behaviour of robots.

=== Communication and security===

*  [[Computer networking|Networking]] – Algorithms and protocols for reliably communicating data across different shared or dedicated media, often including [[error correction]].
*  [[Computer security]] – Practical aspects of securing computer systems and computer networks.
*  [[Cryptography]] – Applies results from complexity, probability, algebra and number theory to invent and [[cryptoanalysis|break codes]], and analyze the security of [[cryptographic protocols]].

=== Computer architecture ===

* [[Computer architecture]] – The design, organization, optimization and verification of a computer system, mostly about [[CPU]]s and [[Memory (computers)|Memory]] subsystem (and the bus connecting them).
*  [[Operating system]]s – Systems for managing computer programs and providing the basis of a usable system.

=== Computer graphics ===

*  [[Computer graphics]] – Algorithms both for generating visual images synthetically, and for integrating or altering visual and spatial information sampled from the real world.
*  [[Image processing]] – Determining information from an image through computation.

=== Concurrent, parallel, and distributed systems ===


* [[Parallel computing]] - The theory and practice of simultaneous computation; data safety in any multitasking or multithreaded environment.
* [[Concurrency (computer science)]] – Computing using multiple concurrent threads of execution, devising algorithms for solving problems on multiple processors to achieve maximal speed-up compared to sequential execution.
* [[Distributed computing]] – Computing using multiple computing devices over a network to accomplish a common objective or task and thereby reducing the latency involved in single processor contributions for any task.

=== Databases ===

* [[Relational databases]] – the [[set theory|set theoretic]] and algorithmic foundation of databases.
* [[Structured Storage]] - non-relational databases such as [[NoSQL]] databases. 
* [[Data mining]] – Study of algorithms for searching and processing information in documents and databases; closely related to [[information retrieval]].

=== Programming languages and compilers ===

* [[Compiler theory]] – Theory of [[compiler]] design, based on [[Automata theory]].
* [[Programming language|Programming language pragmatics]] – Taxonomy of programming languages, their strength and weaknesses. Various [[programming paradigm]]s, such as [[object-oriented programming]].
* [[Programming language theory]]
* [[Formal semantics of programming languages|Formal semantics]] – rigorous mathematical study of the meaning of programs.
* [[Type theory]] – Formal analysis of the types of data, and the use of these types to understand properties of programs — especially program safety.

=== Scientific computing ===
* [[Computational science]] &amp;ndash; constructing [[scientific modeling|mathematical model]]s and [[numerical analysis|quantitative analysis]] techniques and using computers to analyze and solve [[scientific]] problems.
* [[Numerical analysis]] – Approximate numerical solution of mathematical problems such as [[Root-finding algorithm|root-finding]], [[Numerical integration|integration]], the [[Numerical ordinary differential equations|solution of ordinary differential equations]]; the approximation of [[special functions]].
* [[Symbolic computation]] – Manipulation and solution of expressions in symbolic form, also known as [[Computer algebra]].
* [[Computational physics]] – Numerical simulations of large non-analytic systems
* [[Computational chemistry]] – Computational modelling of theoretical chemistry in order to determine chemical structures and properties
* [[Bioinformatics]] and [[Computational biology]] – The use of computer science to maintain, analyse, store [[biological data]] and to assist in solving biological problems such as [[Protein folding]], function prediction and [[Phylogeny]].
* [[Computational neuroscience]] – Computational modelling of [[neurophysiology]].

=== Software engineering ===

* [[Formal methods]] – Mathematical approaches for describing and reasoning about software designs.
* [[Software engineering]] – The principles and practice of designing, developing, and testing programs, as well as proper engineering practices.
*  [[Algorithm design]] – Using ideas from algorithm theory to creatively design solutions to real tasks.
*  [[Computer programming]] – The practice of using a programming language to implement algorithms.
*  [[Human–computer interaction]] – The study and design of computer interfaces that people use.
* [[Reverse engineering]] – The application of the scientific method to the understanding of arbitrary existing software.

=== Theory of computation ===
{{main | Theory of computation}}
* [[Automata theory]] – Different logical structures for solving problems.
* [[Computability theory (computer science)|Computability theory]] – What is calculable with the current models of computers. Proofs developed by [[Alan Turing]] and others provide insight into the possibilities of what may be computed and what may not.
** [[List of unsolved problems in computer science]]
* [[Computational complexity theory]] – Fundamental bounds (especially time and storage space) on classes of computations.
* [[Quantum computing]] theory – Explores computational models involving [[quantum superposition]] of bits.

== History ==

* [[History of computer science]]
* [[List of pioneers in computer science]]

== Professions ==
* [[Programmer]]
* [[Software engineer]]
* [[Software architect]]
* [[Software developer]]
* [[Software tester]]
* [[Interaction designer]]
* [[Network administrator]]

== Basic concepts ==
=== Data and data structures===
* [[Data structure]]
* [[Datatype|Data type]]
* [[Associative array]] and [[Hash table]]
* [[Array data structure|Array]]
* [[List (computing)|List]]
* [[Tree (data structure)|Tree]]
* [[String (computer science)|String]]
* [[Matrix (computer science)]]
* [[Databases|Database]]

===Other ===
* [[Abstraction (computer science)|Abstraction]]
* [[Big O notation]]
* [[Closure (computer science)|Closure]]
* [[Compiler]]

==Programming paradigms==

* [[Imperative programming]]/[[Procedural programming]]
* [[Functional programming]]
* [[Logic programming]]
* [[Object oriented programming]]
** [[Class (computer science)|Class]]
** [[Inheritance (computer science)|Inheritance]]
** [[Object (computer science)|Object]]

== See also ==
{{portal|Computer science}}

* [[Cognitive science]]

== External links ==
{{sisterlinks|Computer science}}

* [http://wikimindmap.com/viewmap.php?wiki=en.wikipedia.org&amp;topic=Outline+of+computer+science&amp;Submit=Search This outline displayed as a mindmap], at ''wikimindmap.com''
* {{dmoz|Computers/Computer_Science/}}
* [http://www.acm.org//education/curricula/ComputerScience2008.pdf [[Association for Computing Machinery|ACM]] report on a recommended computer science curriculum (2008)]
* [http://www.lecturefox.com/computerscience/ Directory of free university lectures in Computer Science]
* [http://liinwww.ira.uka.de/bibliography/ Collection of Computer Science Bibliographies]
* [http://se.ethz.ch/~meyer/gallery/ Photographs of computer scientists] ([[Bertrand Meyer]]'s gallery)

{{Outline footer}}

[[Category:Wikipedia outlines|Computer science]]
[[Category:Computer science| Outline]]
[[Category:Computing-related lists|Computer science topics]]</text>
      <sha1>phhm2vp99s8jxwcagtd4cx9r0cvtyux</sha1>
    </revision>
  </page>
  <page>
    <title>Category:Unsolved problems in computer science</title>
    <ns>14</ns>
    <id>1866234</id>
    <revision>
      <id>685558485</id>
      <parentid>681975746</parentid>
      <timestamp>2015-10-13T15:13:24Z</timestamp>
      <contributor>
        <ip>89.69.114.148</ip>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="219">{{main|List of open problems in computer science}}

[[Category:Computer science]]
[[Category:Theoretical computer science]]
[[Category:Scientific problems|Computer science]]
[[Category:Unsolved problems in mathematics]]</text>
      <sha1>i8dasgpdr40imus456l9jwdpsulzqxu</sha1>
    </revision>
  </page>
  <page>
    <title>Category:Philosophy of computer science</title>
    <ns>14</ns>
    <id>30759626</id>
    <revision>
      <id>717873027</id>
      <parentid>712607006</parentid>
      <timestamp>2016-04-30T06:52:59Z</timestamp>
      <contributor>
        <username>Marcocapelle</username>
        <id>14965160</id>
      </contributor>
      <comment>removed parent categories of [[Category:Philosophy of technology]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="119">{{catmain}}

[[Category:Philosophy of mathematics]]
[[Category:Philosophy of technology]]
[[Category:Computer science]]</text>
      <sha1>630qs35yc9romarohl875439modj76z</sha1>
    </revision>
  </page>
  <page>
    <title>Category:Computer science organizations</title>
    <ns>14</ns>
    <id>2977994</id>
    <revision>
      <id>547393875</id>
      <parentid>452471018</parentid>
      <timestamp>2013-03-28T06:00:47Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>6569922</id>
      </contributor>
      <minor/>
      <comment>[[User:Addbot|Bot:]] Migrating 7 interwiki links, now provided by [[Wikipedia:Wikidata|Wikidata]] on [[d:q8408023]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="131">[[Category:Science organizations by topic]]
[[Category:Computer-related organizations]]
[[Category:Computer science|Organizations]]</text>
      <sha1>nmir9ea3ukib9fpjbsyh2js6xgx3zqp</sha1>
    </revision>
  </page>
  <page>
    <title>Category:Computer science literature</title>
    <ns>14</ns>
    <id>3179625</id>
    <revision>
      <id>747435971</id>
      <parentid>747097447</parentid>
      <timestamp>2016-11-02T11:09:13Z</timestamp>
      <contributor>
        <username>Randykitty</username>
        <id>17843555</id>
      </contributor>
      <comment>wikidata</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="158">==See also==
* [[:Category:Computer science conferences|Computer science conferences]]

[[Category:Computer science|Literature]]
[[Category:Scientific works]]</text>
      <sha1>nnjvw6d12z1o0lrv84wcmo0j2cuiri8</sha1>
    </revision>
  </page>
  <page>
    <title>Category:History of computer science</title>
    <ns>14</ns>
    <id>30730499</id>
    <revision>
      <id>742782032</id>
      <parentid>742781727</parentid>
      <timestamp>2016-10-05T19:16:14Z</timestamp>
      <contributor>
        <username>Look2See1</username>
        <id>11406674</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="180">{{cat main}}

{{DEFAULTSORT:Computer Science, History}}
[[Category:Computer science|History]]
[[Category:History of computing|Computer science]]
[[Category:History of mathematics]]</text>
      <sha1>7nb29zrh9qn8ie8n94e8lbzj2hef46y</sha1>
    </revision>
  </page>
  <page>
    <title>Category:Computer science awards</title>
    <ns>14</ns>
    <id>2379705</id>
    <revision>
      <id>735160450</id>
      <parentid>646789588</parentid>
      <timestamp>2016-08-18T23:27:29Z</timestamp>
      <contributor>
        <username>Cydebot</username>
        <id>1215485</id>
      </contributor>
      <minor/>
      <comment>Robot - Moving category Science and engineering awards to [[:Category:Science and technology awards]] per [[WP:CFD|CFD]] at [[Wikipedia:Categories for discussion/Log/2016 July 18]].</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="133">[[Category:Computer science|Awards]]
[[Category:Computer-related awards]]
[[Category:Science and technology awards|Computer science]]</text>
      <sha1>gxr7s0omuurwbzi5n90u6kpamjpfqv3</sha1>
    </revision>
  </page>
  <page>
    <title>Category:Areas of computer science</title>
    <ns>14</ns>
    <id>33240744</id>
    <revision>
      <id>727466657</id>
      <parentid>709634527</parentid>
      <timestamp>2016-06-29T05:11:07Z</timestamp>
      <contributor>
        <username>Fayenatic london</username>
        <id>1639942</id>
      </contributor>
      <comment>CFR closed as Not renamed, see [[Category talk:Subfields by academic discipline]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="143">
{{Commons category|Areas of computer science}}

[[Category:Computer science| ]]
[[Category:Subfields by academic discipline|Computer science]]</text>
      <sha1>460q9dcakfxd581zbq6kbp64cqol3g6</sha1>
    </revision>
  </page>
  <page>
    <title>Category:Computer scientists</title>
    <ns>14</ns>
    <id>694790</id>
    <revision>
      <id>721808804</id>
      <parentid>709643320</parentid>
      <timestamp>2016-05-24T05:30:06Z</timestamp>
      <contributor>
        <username>Marcocapelle</username>
        <id>14965160</id>
      </contributor>
      <comment>removed [[Category:Mathematical science occupations]]; added [[Category:Mathematicians by field]] using [[WP:HC|HotCat]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="768">{{catdiffuse}}
{{Notice|[[:Category:Computer scientists]] are people who do &quot;''research''&quot; in the field of computer science, which is distinct from people who primarily work on &quot;''developing''&quot; computer software, who would be better placed in [[:Category:Software engineers]] or [[:Category:Computer programmers]].}}

This category of [[Computer scientist]]s consists of people who do research in the field of [[computer science]]: university professors, researchers employed by industry research laboratories, and independent researchers.

{{Category TOC|numerals=no}}
{{Commons cat|Computer scientists}}

[[Category:Computer science| ]]
[[Category:Computer specialists by field]]
[[Category:Scholars and academics by discipline]]
[[Category:Mathematicians by field]]</text>
      <sha1>pbk8la0pub8wk2yl6dfcw2ls3nx381c</sha1>
    </revision>
  </page>
  <page>
    <title>Category:Computer science conferences</title>
    <ns>14</ns>
    <id>2977953</id>
    <revision>
      <id>707444393</id>
      <parentid>588223396</parentid>
      <timestamp>2016-02-28T22:37:21Z</timestamp>
      <contributor>
        <username>Fgnievinski</username>
        <id>6727347</id>
      </contributor>
      <comment>/* See also */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="404">{{Commons category|Computer science conferences}}
[[Academic conference]]s in the field of computer science.

==See also==
* [[:Category:Computer science journals]]
* [[:Category:Conference proceedings]]


[[Category:Academic conferences]]
[[Category:Computer conferences]]
[[Category:Science conferences]]
[[Category:Computer science|Conferences]]
[[Category:Computer science organizations|Conferences]]</text>
      <sha1>e2buro6cjfipzilq7lf09nubwkhgsl3</sha1>
    </revision>
  </page>
  <page>
    <title>Category:Computer science stubs</title>
    <ns>14</ns>
    <id>1859318</id>
    <revision>
      <id>624334193</id>
      <parentid>563250978</parentid>
      <timestamp>2014-09-05T20:47:19Z</timestamp>
      <contributor>
        <username>DexDor</username>
        <id>11025703</id>
      </contributor>
      <comment>rm wikiproject parent category tag (this category contains articles, not wikiproject pages or talk pages)</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="285">{{WPSS-cat}}
{{Stub Category|article=[[computer science]]|newstub=comp-sci-stub|category=Computer science}}
{{Category TOC|numerals=no}}

{{see also|Category:Computer science articles needing expert attention}}

[[Category:Computing stubs|Science]]
[[Category:Science stubs| Computer]]</text>
      <sha1>64w2mqqpnk8tyoaxbpnlvw6gi9bgnu5</sha1>
    </revision>
  </page>
  <page>
    <title>Category:Computer science education</title>
    <ns>14</ns>
    <id>2275290</id>
    <revision>
      <id>753567337</id>
      <parentid>549843833</parentid>
      <timestamp>2016-12-07T23:09:17Z</timestamp>
      <contributor>
        <username>Mazuritz</username>
        <id>16361928</id>
      </contributor>
      <minor/>
      <comment>removed [[Category:Information technology education]] using [[WP:HC|HotCat]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="175">{{Wikiversity}}

[[Category:Computer science|Education]]
[[Category:Computer science organizations|Education]]
[[Category:Education by subject]]
[[Category:Science education]]</text>
      <sha1>8sup45fhvzsqehtf2hkrjfqr9zedx2x</sha1>
    </revision>
  </page>
  <page>
    <title>Technology transfer in computer science</title>
    <ns>0</ns>
    <id>44409131</id>
    <revision>
      <id>693000831</id>
      <parentid>688883340</parentid>
      <timestamp>2015-11-29T20:01:36Z</timestamp>
      <contributor>
        <username>EmausBot</username>
        <id>11292982</id>
      </contributor>
      <minor/>
      <comment>Bot: Migrating 1 interwiki links, now provided by [[Wikipedia:Wikidata|Wikidata]] on [[d:Q21574075]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4807">'''Technology transfer in computer science''' refers to the [[technology transfer|transfer of technology]] developed in [[computer science]] or applied computing research, from universities and governments to the [[private sector]]. These technologies may be abstract, such as [[algorithms]] and [[data structures]], or concrete, such as [[open source software]] packages.

== Examples ==
{{Incomplete list|date=November 2014}}Notable examples of technology transfer in computer science include:
{| class=&quot;wikitable&quot;
!Year of transfer
!Technology
!
Field(s)
!Originally developed at
!Transfer method(s)
!Commercialised at
!Patented
!Used by
|-
|c. 1964
|[[BASIC]]
|[[Programming languages]]
|{{Flagdeco|US}}[[Dartmouth College]]
|[[Freeware]]
|Computer manufacturers and others
|No
|Numerous [[BASIC dialects]]
|-
|1974 (Internet Protocol published)

1992 (interconnection)
|[[The Internet]]
|[[Computer networking]]

[[The Internet]]
|{{Flagdeco|US}}[[DARPA|Advanced Research Projects Agency]]
|[[Request for Comments|RFC]]

1992 law permitting commercial interconnection
|Numerous companies
|No
|Millions of [[web sites]] and other internet properties
|-
|1981
|[[KMS (hypertext)|KMS]]
|[[Hypertext]]
|{{Flagdeco|US}}[[Carnegie Mellon University]]
|Spin-out
|Knowledge Systems
|No
|?
|-
|1984
|[[MATLAB]]
|[[Programming languages]]

[[Scientific computing]]

[[List of numerical analysis software|Numerical computing]]
|{{Flagdeco|US}}[[University of New Mexico]]&lt;ref name=&quot;:0&quot;&gt;{{Cite web|url = http://uk.mathworks.com/company/newsletters/articles/the-origins-of-matlab.html|title = The Origins of MATLAB|date = 2004|accessdate = 19 November 2014|website = Mathworks.com|publisher = |last = Moler|first = Cleve}}&lt;/ref&gt;
|Incorporation and rewrite&lt;ref name=&quot;:0&quot; /&gt;
|{{Flagdeco|US}}[[MathWorks]]
|No (original)

Yes (from 2001)&lt;ref&gt;{{Cite web|url = http://uk.mathworks.com/company/aboutus/policies_statements/patents.html|title = Patents|date = |accessdate = 19 November 2014|website = Mathworks.com|publisher = |last = |first = }}&lt;/ref&gt;
|Millions of users
|-
|c. 1985
|[[HyperTIES]]
|[[Hypertext]]
|{{Flagdeco|US}}[[University of Maryland]]&lt;ref name=&quot;:1&quot;&gt;{{Cite web|url = http://www.cs.umd.edu/hcil/hyperties/|title = Hypertext Research: The Development of HyperTIES|date = |accessdate = 22 November 2014|website = Human Computer Interaction Lab|publisher = University of Maryland|last = |first = }}&lt;/ref&gt;
|[[Intellectual property license|Licensing]]&lt;ref name=&quot;:1&quot; /&gt;
|{{Flagdeco|US}}[[Cognetics Corporation]]
|?
|[[Union Carbide]], [[Hewlett-Packard]], others&lt;ref name=&quot;cognetics-hyperties&quot;&gt;{{cite web|url=http://www.leadersintheknow.biz/AboutUs/OurHistory/tabid/174/Default.aspx|title=Cognetics History|publisher=[[Cognetics Corporation]]|accessdate = 22 November 2014}}&lt;/ref&gt;
|-
|1990 (initial software)

1994 (Netscape)&lt;ref&gt;{{Cite web|url = http://arstechnica.com/business/2011/10/before-netscape-forgotten-web-browsers-of-the-early-1990s/|title = Before Netscape: the forgotten Web browsers of the early 1990s|date = 11 October 2011|accessdate = 22 November 2014|website = [[Ars Technica]]|publisher = |last = Lasar|first = Matthew}}&lt;/ref&gt;
|[[World Wide Web]]
|[[Hypertext]]

[[World Wide Web]]
|{{Flagdeco|Switzerland}}[[CERN]]
|Unfettered use (no patents)
[[W3C|Consortium]] (to create recommended standards)
|{{Flagdeco|US}}[[Netscape]] and others
|No
|Millions of [[web sites]]
|-
|1991
|[[Gopher (protocol)|Gopher]]
|[[Computer networking]]

[[The Internet]]

[[Information retrieval]]
|{{Flagdeco|US}}[[University of Minnesota]]
|[[Request for Comments|RFC]]

[[Freeware]]
|Numerous companies
|No
|Numerous Gopher sites
|-
|1998
|[[PageRank]]
|[[Information retrieval]]

[[World Wide Web]]

[[Algorithms]]
|{{Flagdeco|US}}[[Stanford University]]
|[[Spin-out]]
|{{Flagdeco|US}}[[Google Inc.|Google]]
|Yes
|[[Google Search]]
|-
|2004 (software)

2011 (incorporation)
|[[Scala (programming language)|Scala]]
|[[Programming languages]]

[[Object-oriented programming]]
|{{Flagdeco|Switzerland}}[[École Polytechnique Fédérale de Lausanne]]
|Open source
|{{Flagdeco|US}}[[Typesafe Inc.]] and others
|?
|[[Play framework|Play]], [[Akka (toolkit)|Akka]] and others
|-
|2013
|[[Conflict-free replicated data types|CRDTs]]
|[[Distributed computing]]
|{{Flagdeco|France}}[[INRIA]] and others
|?
|{{Flagdeco|US}}[[Basho Technologies]]&lt;ref name=&quot;:2&quot;&gt;{{Cite web|url = http://basho.com/introducing-riak-2-0/|title = Introducing Riak 2.0: Data Types, Strong Consistency, Full-Text Search, and Much More|date = 29 October 2013|accessdate = 29 November 2014|website = |publisher = [[Basho Technologies]]|last = |first = }}&lt;/ref&gt;
|No
|[[Riak]]&lt;ref name=&quot;:2&quot; /&gt;
|}

== References ==
&lt;references /&gt;[[Category:Technology transfer|Computer science]]
[[Category:Computer science]]
[[Category:Computing-related lists]]</text>
      <sha1>7p9mwpljz0fc2d68kpm13hdmdej7kez</sha1>
    </revision>
  </page>
  <page>
    <title>Visual computing</title>
    <ns>0</ns>
    <id>45350085</id>
    <revision>
      <id>755373586</id>
      <parentid>755368962</parentid>
      <timestamp>2016-12-17T17:06:11Z</timestamp>
      <contributor>
        <username>Pixel977</username>
        <id>15158697</id>
      </contributor>
      <minor/>
      <comment>/* External links */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6869">'''Visual computing''' is a generic term for all computer science disciplines handling with images and 3D models, i.e. computer graphics, image processing, visualization, computer vision, virtual and augmented reality, video processing, but also includes aspects of pattern recognition, human computer interaction, machine learning and digital libraries. The core challenges are the acquisition, processing, analysis and rendering of visual information (mainly images and video). Application areas include industrial quality control, medical image processing and visualization, surveying, robotics, multimedia systems, virtual heritage, special effects in movies and television, and computer games.

==History and overview==
Visual computing is a relatively newly coined term, which got its current meaning around 2005,&lt;ref&gt;[http://www.isvc.net/ International Symposium on Visual Computing]&lt;/ref&gt; when the established computer science disciplines [[computer graphics]], [[image processing]], [[computer vision]] and others noticed that their methods and applications overlapped more and more, so that a new generic term was needed. Many of the used mathematical and algorithmic methods are the same in all areas dealing with images: image formats, filtering methods, color models, image metrics and others. And also the programming methods on graphics hardware, the manipulation tricks to handle huge data, textbooks and conferences, the scientific communities of these disciplines and working groups at companies intermixed more and more.

Furthermore, applications increasingly needed techniques from more than one of these fields concurrently. To generate very detailed models of complex objects you need image recognition, 3D sensors and reconstruction algorithms, and to display these models believably you need realistic rendering techniques with complex lighting simulation. Real-time graphics is the basis for usable virtual and augmented reality software. A good segmentation of the organs is the basis for interactive manipulation of 3D visualizations of medical scans. Robot control needs the recognition of objects just as a model of its environment. And all devices (computers) need ergonomic graphical user interfaces.

Although many problems are considered solved within the scientific communities of the sub-disciplines making up visual computing (mostly under idealistic assumptions), one major challenge of visual computing as a whole is the integration of these partial solutions into applicable products. This includes dealing with many practical problems like addressing a multitude of hardware, the use of real data (that is often erroneous and/or gigantic in size), and the operation by untrained users. In this respect, '''Visual computing is more than just the sum of its sub-disciplines''', it is the next step towards systems fit for real use in all areas using images or 3D objects on the computer.

== Visual computing disciplines ==
At least the following disciplines are sub-fields of visual computing. More detailed descriptions of each of these fields can be found on the linked special pages.
* Computer graphics and computer animation
[[Computer graphics (computer science)|Computer graphics]] is a general term for all techniques that produce images as result with the help of a computer. To transform the description of objects to nice images is called [[Rendering (computer graphics)|rendering]] which is always a compromise between image quality and run-time.
* Image analysis and computer vision
Techniques that can extract content information from images are called [[image analysis]] techniques. [[Computer vision]] is the ability of computers (or of robots) to recognize their environment and to interpret it correctly.
* Visualization and visual analytics
[[Visualization (computer graphics)|Visualization]] is used to produce images that shall communicate messages. Data may be abstract or concrete, often with no a priori geometrical components. [[Visual analytics]] describes the discipline of interactive visual analysis of data, also described as “the science of analytical reasoning supported by the interactive visual interface”.&lt;ref&gt;[Thomas, J.J., and Cook, K.A. (Eds) (2005). An Illuminated Path: The Research and Development Agenda for Visual Analytics, IEEE Computer Society Press, ISBN 0-7695-2323-4]&lt;/ref&gt;
* Geometric modeling and 3D-printing
To represent objects for rendering it needs special methods and data structures, which subsumed with the term [[geometric modeling]]. In addition to describing and interactive geometric techniques, sensor data are more and more used to reconstruct geometrical models. Algorithms for the efficient control of [[3D printing|3D printers]] also belong to the field of visual computing.
* Image processing and image editing
In contrast to image analysis [[image processing]] manipulates images to produce better images. “Better” can have very different meanings subject to the respective application. Also, it has to be discriminated from [[image editing]] which describes interactive manipulation of images based on human validation.
* Virtual and augmented reality
Techniques that produce the feeling of immersion into a fictive world are called [[virtual reality]] (VR). Requirements for VR include [[head-mounted display]]s, real-time tracking, and high-quality real-time rendering. [[Augmented reality]] enables the user to see the real environment in addition to the virtual objects, which augment this reality. Accuracy requirements on rendering speed and tracking precision are significantly higher here.
* Human computer interaction
The planning, design and uses of interfaces between people and computers is not only part of every system involving images. Due to the high bandwidth of the human visual channel (eye), images are also a preferred part of ergonomic user interfaces in any system, so that [[human-computer interaction]] is also an integral part of visual computing.

== Footnotes ==
&lt;references /&gt;

== External links ==
* [http://research.microsoft.com/en-us/groups/vc/ Microsoft Research Group Visual Computing]
* [http://www.nvidia.de/object/visual-computing-de.html Visual Computing at NVidia]
* [http://vcg.seas.harvard.edu/ Visual Computing Group at Harvard University]
* [http://vcc.kaust.edu.sa/Pages/Home.aspx Visual Computing Center at KAUST]
* [http://www.igd.fraunhofer.de/ Applied Research in Visual Computing] (Fraunhofer IGD)
* [http://www.ivc.h-brs.de/ Institute of Visual Computing] (Hochschule Bonn-Rhein-Sieg, Sankt Augustin)
* [http://www.vrvis.at  VRVis Research Center for Virtual Reality and Visualisation] (Vienna, Austria)
* [http://www.visual-computing.com Visual Computing Group @ HTW Berlin] (Germany)

{{Authority control}}

[[Category:Computer science]]
[[Category:Image processing]]
[[Category:Computer graphics]]</text>
      <sha1>p5gbmyc45pl4bq3ob6hw5w7jac9vrhg</sha1>
    </revision>
  </page>
  <page>
    <title>Portal:Computer science</title>
    <ns>100</ns>
    <id>1472580</id>
    <revision>
      <id>744217785</id>
      <parentid>744214893</parentid>
      <timestamp>2016-10-13T21:05:50Z</timestamp>
      <contributor>
        <username>John of Reading</username>
        <id>11308236</id>
      </contributor>
      <comment>Reverted 1 edit by [[Special:Contributions/103.230.105.2|103.230.105.2]] ([[User talk:103.230.105.2|talk]]): Undo off-topic additions. ([[WP:TW|TW]])</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4764">&lt;!-- This portal was created using subst:box portal skeleton  --&gt;
{{Portals browsebar}}
{| width=&quot;100%&quot; cellpadding=&quot;5&quot; cellspacing=&quot;10&quot; style=&quot;background:#FFFFFF; border-style:solid; border-width:1px; border-color:#FFFF33;&quot;
| width=&quot;55%&quot; style=&quot;vertical-align:top;padding: 0; margin:0;&quot; | 
{{Shortcut|P:CS}}

:{{resize|95%|This portal is for the [[List of academic disciplines|academic discipline]] of '''computer science'''. For other related portals such as [[Portal:Computer networking|computer networking]], [[Portal:Computer security|computer security]] and [[Portal:Information technology|information technology]], please see '''[[Portal:Contents/Portals#Technology and applied sciences|portals: technology and applied sciences]]'''.''
}}
&lt;div style=&quot;clear:both; width:100%&quot;&gt;
{{/box-header|&lt;big&gt;The Computer Science Portal&lt;/big&gt;|{{FULLPAGENAME}}/Intro|}}
{{{{FULLPAGENAME}}/Intro}}
{{/box-footer|}}
&lt;/div&gt;

&lt;div style=&quot;text-align:center; margin:0.25em auto 0.75em&quot;&gt;{{purge|'''Show new selections'''}}&lt;/div&gt;

&lt;div class=&quot;portal-column-left&quot;&gt; &lt;!-- Switch to one column on narrow screens --&gt;

{{/box-header|''Selected quote''|{{FULLPAGENAME}}/Selected quote|}}
{{Selected quote
| quote = ...the unfactored criterion &quot;A program is good (enough) as long as it satisfies your customers.&quot; is too woolly to be of '''any''' help.
| quoted = Edsger W. Dijkstra
| dates = 1930-2002
| source = http://www.cs.utexas.edu/~EWD/transcriptions/EWD06xx/EWD603.html EWD603: Tripreport, E.W.Dijkstra Archive
}}
{{/box-footer|}}

{{Random portal component|max=6|header=''Featured article''|subpage=Featured article|seed=3}}

{{/box-header|''Selected picture''|{{FULLPAGENAME}}/Selected picture|}}
{{{{FULLPAGENAME}}/Selected picture}}
{{/box-footer|}}

{{/box-header|''Categories''|{{FULLPAGENAME}}/Categories|}}
{{{{FULLPAGENAME}}/Categories}}
{{/box-footer|}}

{{/box-header|''Related WikiProjects''|{{FULLPAGENAME}}/WikiProjects|}}
{{{{FULLPAGENAME}}/WikiProjects}}
{{/box-footer|}}

&lt;/div&gt;

&lt;div class=&quot;portal-column-right&quot;&gt; &lt;!-- Switch to one column on narrow screens --&gt;

{{/box-header|''Selected biography''|{{FULLPAGENAME}}/Selected person|}}
{{Selected biography
| image = Vint_Cerf_-_2010.jpg
| size = 150px
| side = right
| caption = Vint Cerf was elected as the president of the [[Association for Computing Machinery]] in May 2012, and in August 2013 he joined the Council on CyberSecurity's Board of Advisors..
| name = Vinton Gray Cerf
| born = 1943
| link = Vint Cerf
| text = Vinton Gray &quot;Vint&quot; Cerf[1] (/ˈsɜrf/; born June 23, 1943) is an American computer scientist, who is recognized as one of &quot;the fathers of the Internet&quot;, sharing this title with American computer scientist Bob Kahn. His contributions have been acknowledged and lauded, repeatedly, with honorary degrees and awards that include the National Medal of Technology, the [[Turing Award]], the Presidential Medal of Freedom, and membership in the National Academy of Engineering.

In the early days, Cerf was a program manager for the United States Department of Defense Advanced Research Projects Agency (DARPA) funding various groups to develop TCP/IP technology. When the Internet began to transition to a commercial opportunity during the late 1980s, Cerf moved to MCI where he was instrumental in the development of the first commercial email system (MCI Mail) connected to the Internet.

Cerf was instrumental in the funding and formation of ICANN from the start. He waited in the wings for a year before he stepped forward to join the ICANN Board, eventually becoming chairman.

Cerf went to Van Nuys High School along with Jon Postel and Steve Crocker; he wrote the former's obituary. Both were also instrumental in the creation of the Internet.

Cerf is also known for his sartorial style, typically appearing in three-piece suit—a rarity in an industry known for its casual dress norms.
}}
{{/box-footer|}}

{{/box-header|''Related portals''|{{FULLPAGENAME}}/Related portals|}}
{{{{FULLPAGENAME}}/Related portals}}
{{/box-footer|}}

{{/box-header|''Things you can do''|{{FULLPAGENAME}}/Things you can do|}}
{{{{FULLPAGENAME}}/Things you can do}}
{{/box-footer|}}

&lt;/div&gt;

&lt;div style=&quot;clear:both; width:100%&quot;&gt;

{{/box-header|''{{PAGENAME}} topics''|{{FULLPAGENAME}}/{{PAGENAME}} topics|}}
{{{{FULLPAGENAME}}/{{PAGENAME}} topics}}
{{/box-footer|}}

{{/box-header|''Associated Wikimedia''|Template:WikimediaForPortals|}}
{{WikimediaForPortals|species=no}}
{{/box-footer|}}

&lt;center&gt;[[Special:PrefixIndex/Portal:Computer_science|Directory of pages for ''Portal:Computing_science'']]
&lt;/center&gt;

&lt;/div&gt;

{{portals}}
{{purge page}}

__NOTOC__ __NOEDITSECTION__

[[Category:{{PAGENAME}} portal|*]]
[[Category:Computing portals]]
[[Category:Science portals]]
[[Category:Computer science|ρ]]</text>
      <sha1>33o0ky533w3vdi5mnixskxt9d5laqq2</sha1>
    </revision>
  </page>
  <page>
    <title>Philosophy of computer science</title>
    <ns>0</ns>
    <id>22458313</id>
    <revision>
      <id>766368838</id>
      <parentid>744857388</parentid>
      <timestamp>2017-02-19T20:29:52Z</timestamp>
      <contributor>
        <username>Tassedethe</username>
        <id>7098284</id>
      </contributor>
      <comment>Disambiguated: [[Ray Turner]] → [[Ray Turner (computer scientist)]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3660">__NOTOC__
The '''philosophy of computer science''' is concerned with the [[philosophy|philosophical]] questions that arise with the study of [[computer science]], which is understood to mean not just [[Computer programming|programming]] but the whole study of concepts and methods that assist in the development and maintenance of [[computer system]]s.&lt;ref name=&quot;stanford&quot;&gt;Turner&lt;/ref&gt; According to {{harv|Tedre|2006}}, there is still no common understanding of the content, aim, focus, or topic of the philosophy of computer science, despite some attempts to develop a philosophy of computer science like the [[philosophy of physics]] or the [[philosophy of mathematics]].

The philosophy of computer science as such deals with the meta-activity that is associated with the development of the concepts and methodologies that implement and analyze the computational systems.&lt;ref&gt;http://pcs.essex.ac.uk/&lt;/ref&gt;

==See also==
* [[Computer-assisted proof#Philosophical objections|Computer-assisted proof: Philosophical objections]]
* [[Philosophy of artificial intelligence]]
* [[Philosophy of information]]
* [[Philosophy of mathematics]]
* [[Philosophy of science]]
* [[Philosophy of technology]]

==References==
{{Reflist|2}}

==Further reading==
* [[Scott Aaronson]]. &quot;[http://eccc.hpi-web.de/report/2011/108/ Why Philosophers Should Care About Computational Complexity]&quot;. In ''Computability: Gödel, Turing, Church, and beyond''.
* [[Timothy Colburn]]. ''Philosophy and Computer Science''. Explorations in Philosophy. M.E. Sharpe, 1999. ISBN 1-56324-991-X.
* [[A.K. Dewdney]]. ''New Turning Omnibus: 66 Excursions in Computer Science''
* [[Luciano Floridi]] (editor). ''The Blackwell Guide to the Philosophy of Computing and Information'', 2004.
* [[Luciano Floridi]] (editor). ''Philosophy of Computing and Information: 5 Questions''. Automatic Press, 2008.
* [[Luciano Floridi]]. ''Philosophy and Computing: An Introduction'', Routledge, 1999.
* [[Christian Jongeneel]]. ''The informatical worldview, an inquiry into the methodology of computer science''.
* [[Jan van Leeuwen]]. [http://www.nias.knaw.nl/Content/NIAS/Publicaties/Newsletter/NIAS_Newsletter_42.pdf &quot;Towards a philosophy of the information and computing sciences&quot;], ''NIAS Newsletter'' '''42''', 2009.
* Moschovakis, Y. (2001). What is an algorithm? In Enquist, B. and Schmid, W., editors, Mathematics unlimited &amp;mdash; 2001 and beyond, pages 919–936. Springer.
* [[Alexander Ollongren]], [[Jaap van den Herik]]. ''Filosofie van de informatica''. London and New York: Routledge, 1999. ISBN 0-415-19749-X
* {{cite|first=Matti|last=Tedre|year=2014|url=https://books.google.fr/books?id=I2tYBQAAQBAJ|title=The Science of Computing: Shaping a Discipline}} Taylor and Francis.
* [[Ray Turner (computer scientist)|Ray Turner]] and [[Ammon H. Eden]]. &quot;[http://plato.stanford.edu/entries/computer-science/ The Philosophy of Computer Science]&quot;. ''[[Stanford Encyclopedia of Philosophy]]''.
* [[Matti Tedre]] (2011). ''[http://www.springerlink.com/content/v66j682n57602453/ Computing as a Science: A Survey of Competing Viewpoints]''. Minds &amp; Machines '''21''', 3, 361–387.

==External links==
* [http://www.iacap.org/ The International Association for Computing and Philosophy]
* [http://philpapers.org/browse/philosophy-of-computing-and-information Philosophy of Computing and Information] at [[PhilPapers]]
* A draft version of [http://www.cse.buffalo.edu/~rapaport/Papers/phics.pdf ''Philosophy of Computer Science''] by [[William J. Rapaport]]

{{Computer science}}
{{Philosophy of science}}

[[Category:Philosophy of computer science| ]]
[[Category:Computer science]]

{{computer science stub}}</text>
      <sha1>berhfqdgyt7swuluj2t6d9axcmza3n8</sha1>
    </revision>
  </page>
  <page>
    <title>Computer science</title>
    <ns>0</ns>
    <id>5323</id>
    <revision>
      <id>771021423</id>
      <parentid>768865987</parentid>
      <timestamp>2017-03-19T01:32:32Z</timestamp>
      <contributor>
        <username>CitationCleanerBot</username>
        <id>15270283</id>
      </contributor>
      <minor/>
      <comment>Cleanup SSRN links. Report bugs, errors, and suggestions at [[User talk:CitationCleanerBot]].</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="60165">{{pp-vandalism|small=yes}}
{{pp-move-indef|small=yes}}
{{use mdy dates|datdae=December 2014|date=August 2015}}
{{Science}}
&lt;div class=&quot;thumb tright&quot;&gt;
&lt;div class=&quot;thumbinner&quot; style=&quot;width:300px;&quot;&gt;
{| style=&quot;border:1px solid #ccc;&quot;
|-
| [[File:Lambda lc.svg|144px|alt=large capital lambda|Programming language theory|link=Programming language theory]]
| [[File:Sorting quicksort anim frame.svg|144px|alt=Plot of a quicksort algorithm|Computational complexity theory|link=Computational complexity theory]]
|-
| [[File:Utah teapot simple 2.png|144px|alt=Utah teapot representing computer graphics|Computer graphics|link=Computer graphics (computer science)]]
| [[File:3-Tasten-Maus Microsoft.jpg|144px|alt=Microsoft Tastenmaus mouse representing human-computer interaction|Human–computer interaction|link=Human–computer interaction]]
|}
&lt;div class=&quot;thumbcaption&quot;&gt;Computer science deals with the theoretical foundations of information and computation, together with practical techniques for the implementation and application of these foundations.&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

'''Computer science''' is the study of the theory, experimentation, and engineering that form the basis for the design and use of [[computer]]s. It is the scientific and practical approach to [[computation]] and its applications and the systematic study of the feasibility, structure, expression, and mechanization of the methodical [[Procedure (computer science)|procedures]] (or [[algorithm]]s) that underlie the acquisition, representation, processing, storage, communication of, and access to [[information]]. An alternate, more succinct definition of computer science is the study of automating algorithmic processes that scale. A [[computer scientist]] specializes in the theory of computation and the design of computational systems.&lt;ref&gt;{{cite web |url=http://wordnetweb.princeton.edu/perl/webwn?s=computer%20scientist |title=WordNet Search—3.1 |publisher=Wordnetweb.princeton.edu |accessdate=2012-05-14}}&lt;/ref&gt;

Its fields can be divided into a variety of theoretical and [[practical disciplines]]. Some fields, such as [[computational complexity theory]] (which explores the fundamental properties of [[Computational problem|computational]] and intractable problems), are highly abstract, while fields such as [[Computer graphics (computer science)|computer graphics]] emphasize real-world visual applications. Other fields still focus on challenges in implementing computation. For example, [[programming language theory]] considers various approaches to the description of computation, while the study of [[computer programming]] itself investigates various aspects of the use of [[programming language]] and [[complex systems]]. [[Human–computer interaction]] considers the challenges in making computers and computations useful, usable, and [[Computer accessibility|universally accessible]] to [[human]]s.
{{TOClimit|4}}

==History==
{{main article|History of computer science}}
{{History of computing}}
[[File:Babbage40.png|upright|thumb|[[Charles Babbage]] is sometimes referred as &quot;father of computing&quot;.&lt;ref&gt;{{Cite web|url=http://www.cbi.umn.edu/about/babbage.html|title=Charles Babbage Institute: Who Was Charles Babbage?|website=www.cbi.umn.edu|access-date=2016-12-28}}&lt;/ref&gt; ]]
[[File:Ada lovelace.jpg|upright|thumb|[[Ada Lovelace]] is credited with writing the first [[algorithm]] intended for processing on a computer.&lt;ref&gt;{{Cite web|url=http://www.computerhistory.org/babbage/adalovelace/|title=Ada Lovelace {{!}}  Babbage Engine {{!}} Computer History Museum|website=www.computerhistory.org|access-date=2016-12-28}}&lt;/ref&gt; ]]

The earliest foundations of what would become computer science predate the invention of the modern [[digital computer]]. Machines for calculating fixed numerical tasks such as the [[abacus]] have existed since antiquity, aiding in computations such as multiplication and division. Further, [[algorithm]]s for performing computations have existed since antiquity, even before the development of sophisticated computing equipment.

[[Wilhelm Schickard]] designed and constructed the first working [[mechanical calculator]] in 1623.&lt;ref&gt;{{cite web|title=Wilhelm Schickard - Ein Computerpionier|url=http://www.fmi.uni-jena.de/fmimedia/Fakultaet/Institute+und+Abteilungen/Abteilung+f%C3%BCr+Didaktik/GDI/Wilhelm+Schickard.pdf}}&lt;/ref&gt; In 1673, [[Gottfried Leibniz]] demonstrated a digital mechanical calculator, called the [[Stepped Reckoner]].&lt;ref&gt;{{cite web|title=A Brief History of Computing|url=http://blogs.royalsociety.org/history-of-science/2012/06/25/history-of-computing/}}&lt;/ref&gt; He may be considered the first computer scientist and information theorist, for, among other reasons, documenting the binary number system. In 1820, [[Charles Xavier Thomas|Thomas de Colmar]] launched the [[mechanical calculator]] industry&lt;ref group=note&gt;In 1851&lt;/ref&gt; when he released his simplified [[arithmometer]], which was the first calculating machine strong enough and reliable enough to be used daily in an office environment. [[Charles Babbage]] started the design of the first ''automatic mechanical calculator'', his [[Difference Engine]], in 1822, which eventually gave him the idea of the first ''programmable mechanical calculator'', his [[Analytical Engine]].&lt;ref&gt;{{cite web |url=http://www.sciencemuseum.org.uk/on-line/babbage/index.asp |title=Science Museum—Introduction to Babbage |accessdate=2006-09-24 |archiveurl=https://web.archive.org/web/20060908054017/http://www.sciencemuseum.org.uk/on-line/babbage/index.asp |archivedate=2006-09-08}}&lt;/ref&gt; He started developing this machine in 1834, and &quot;in less than two years, he had sketched out many of the salient features of the modern [[computer]]&quot;.&lt;ref name=&quot;Hyman1982&quot;&gt;{{cite book |author=Anthony Hyman |title=Charles Babbage, pioneer of the computer |year=1982}}&lt;/ref&gt; &quot;A crucial step was the adoption of a punched card system derived from the [[Jacquard loom]]&quot;&lt;ref name=&quot;Hyman1982&quot; /&gt; making it infinitely programmable.&lt;ref group=note&gt;&quot;The introduction of punched cards into the new engine was important not only as a more convenient form of control than the drums, or because programs could now be of unlimited extent, and could be stored and repeated without the danger of introducing errors in setting the machine by hand; it was important also because it served to crystallize Babbage's feeling that he had invented something really new, something much more than a sophisticated calculating machine.&quot; [[#COLLIER|Bruce Collier]], 1970&lt;/ref&gt; In 1843, during the translation of a French article on the Analytical Engine, [[Ada Lovelace]] wrote, in one of the many notes she included, an algorithm to compute the [[Bernoulli number]]s, which is considered to be the first computer program.&lt;ref&gt;{{cite web|url=http://www.scottlan.edu/Lriddle/women/ada-love.htm |title=A Selection and Adaptation From Ada's Notes found in Ada, The Enchantress of Numbers,&quot; by Betty Alexandra Toole Ed.D. Strawberry Press, Mill Valley, CA |accessdate=2006-05-04 |deadurl=yes |archiveurl=https://web.archive.org/web/20060210172109/http://www.scottlan.edu/lriddle/women/ada-love.htm |archivedate=February 10, 2006 }}&lt;/ref&gt; Around 1885, [[Herman Hollerith]] invented the [[tabulating machine|tabulator]], which used [[punched card]]s to process statistical information; eventually his company became part of [[IBM]]. In 1937, one hundred years after Babbage's impossible dream, [[Howard H. Aiken|Howard Aiken]] convinced IBM, which was making all kinds of punched card equipment and was also in the calculator business&lt;ref&gt;&quot;In this sense Aiken needed IBM, whose technology included the use of punched cards, the accumulation of numerical data, and the transfer of numerical data from one register to another&quot;, [[#AIKEN|Bernard Cohen]], p.44 (2000)&lt;/ref&gt; to develop his giant programmable calculator, the [[Harvard Mark I|ASCC/Harvard Mark I]], based on Babbage's Analytical Engine, which itself used cards and a central computing unit. When the machine was finished, some hailed it as &quot;Babbage's dream come true&quot;.&lt;ref&gt;[[#ORIGINS|Brian Randell]], p. 187, 1975&lt;/ref&gt;

During the 1940s, as new and more powerful [[computing]] machines were developed, the term ''computer'' came to refer to the machines rather than their human predecessors.&lt;ref&gt;The [[Association for Computing Machinery]] (ACM) was founded in 1947.&lt;/ref&gt; As it became clear that computers could be used for more than just mathematical calculations, the field of computer science broadened to study [[computation]] in general. Computer science began to be established as a distinct academic discipline in the 1950s and early 1960s.&lt;ref name=&quot;Denning_cs_discipline&quot;/&gt;&lt;ref&gt;{{cite web |url=http://www.cl.cam.ac.uk/conference/EDSAC99/statistics.html |title=Some EDSAC statistics |publisher=Cl.cam.ac.uk |accessdate=2011-11-19}}&lt;/ref&gt; The world's first computer science degree program, the [[Cambridge Diploma in Computer Science]], began at the [[University of Cambridge]] [[Cambridge Computer Lab|Computer Laboratory]] in 1953. The first computer science degree program in the United States was formed at [[Purdue University]] in 1962.&lt;ref&gt;{{cite web |url=http://www.cs.purdue.edu/about/conte.html |title=Computer science pioneer Samuel D. Conte dies at 85 |date=July 1, 2002 |publisher=Purdue Computer Science |accessdate=December 12, 2014}}&lt;/ref&gt; Since practical computers became available, many applications of computing have become distinct areas of study in their own rights.

Although many initially believed it was impossible that computers themselves could actually be a scientific field of study, in the late fifties it gradually became accepted among the greater academic population.&lt;ref name=&quot;Levy1984&quot;&gt;{{cite book |authorlink=Steven Levy |last=Levy |first=Steven |title=[[Hackers: Heroes of the Computer Revolution]] |year=1984 |isbn=0-385-19195-2 |publisher=Doubleday }}&lt;/ref&gt;&lt;ref name=&quot;Tedre2014&quot;&gt;{{cite book |last=Tedre |first=Matti |title=The Science of Computing: Shaping a Discipline |year=2014 |publisher=Taylor and Francis / CRC Press }}&lt;/ref&gt; It is the now well-known [[IBM]] brand that formed part of the computer science revolution during this time. IBM (short for International Business Machines) released the IBM 704&lt;ref&gt;{{cite web|url=http://www.computerhistory.org/revolution/computer-graphics-music-and-art/15/222/633 |title=IBM 704 Electronic Data Processing System—CHM Revolution |publisher=Computerhistory.org |accessdate=2013-07-07}}&lt;/ref&gt; and later the IBM 709&lt;ref&gt;{{cite web |title=IBM 709: a powerful new data processing system |publisher=Computer History Museum |url=http://archive.computerhistory.org/resources/text/IBM/IBM.709.1957.102646304.pdf |accessdate=December 12, 2014}}&lt;/ref&gt; computers, which were widely used during the exploration period of such devices. &quot;Still, working with the IBM [computer] was frustrating […] if you had misplaced as much as one letter in one instruction, the program would crash, and you would have to start the whole process over again&quot;.&lt;ref name=&quot;Levy1984&quot;/&gt; During the late 1950s, the computer science discipline was very much in its developmental stages, and such issues were commonplace.&lt;ref name=&quot;Tedre2014&quot;/&gt;

Time has seen significant improvements in the usability and effectiveness of [[computing technology]].&lt;ref&gt;{{cite web|title = Timeline of Computer History|url = http://www.computerhistory.org/timeline/computers/|publisher = Computer History Museum|accessdate = November 24, 2015}}&lt;/ref&gt; Modern society has seen a significant shift in the users of computer technology, from usage only by experts and professionals, to a near-ubiquitous user base. Initially, computers were quite costly, and some degree of human aid was needed for efficient use—in part from professional computer operators. As computer adoption became more widespread and affordable, less human assistance was needed for common usage.
{{see also|History of computing|History of informatics}}

===Contributions===
[[File:Enigma.jpg|thumb|upright|The [[Germany|German]] military used the [[Enigma machine]] (shown here) during [[World War II]] for communications they wanted kept secret. The large-scale decryption of Enigma traffic at [[Bletchley Park]] was an important factor that contributed to Allied victory in WWII.&lt;ref name=&quot;kahnbook&quot;/&gt;]]

Despite its short history as a formal academic discipline, computer science has made a number of fundamental contributions to [[science]] and [[society]]—in fact, along with [[electronics]], it is a founding science of the current epoch of human history called the [[Information Age]] and a driver of the [[information revolution|Information Revolution]], seen as the third major leap in human technological progress after the [[Industrial Revolution]] (1750–1850 CE) and the [[Neolithic Revolution|Agricultural Revolution]] (8000–5000 BC).

These contributions include:
* The start of the &quot;[[Digital Revolution|digital revolution]]&quot;, which includes the current [[Information Age]] and the [[Internet]].&lt;ref name=&quot;bgu&quot;&gt;{{cite web|title=Computer Science : Achievements and Challenges circa 2000 |url=http://www.cis.cornell.edu/Dean/Presentations/Slides/bgu.pdf |accessdate=January 11, 2007 |deadurl=yes |archiveurl=https://web.archive.org/web/20060911104502/http://www.cis.cornell.edu/Dean/Presentations/Slides/bgu.pdf |archivedate=September 11, 2006 }}&lt;/ref&gt;
* A formal definition of [[computation]] and [[computability]], and proof that there are computationally [[Undecidable problem|unsolvable]] and [[Computational complexity theory#Intractability|intractable]] problems.&lt;ref&gt;{{Cite journal |author=Constable, R. L. |date=March 2000 |url=http://www.cs.cornell.edu/cis-dean/bgu.pdf | title=Computer Science: Achievements and Challenges circa 2000 |format=PDF}}&lt;/ref&gt;
* The concept of a [[programming language]], a tool for the precise expression of methodological information at various levels of abstraction.&lt;ref&gt;{{cite book |last=Abelson |first=H. |authorlink=Hal Abelson |author2=G.J. Sussman with J. Sussman |year=1996 |title=[[Structure and Interpretation of Computer Programs]] |edition=2nd |publisher=MIT Press |isbn=0-262-01153-0 |quote=The computer revolution is a revolution in the way we think and in the way we express what we think. The essence of this change is the emergence of what might best be called ''procedural epistemology'' — the study of the structure of knowledge from an imperative point of view, as opposed to the more declarative point of view taken by classical mathematical subjects.}}&lt;/ref&gt;
* In [[cryptography]], [[Cryptanalysis of the Enigma|breaking the Enigma code]] was an important factor contributing to the Allied victory in World War II.&lt;ref name=&quot;kahnbook&quot;&gt;[[David Kahn (writer)|David Kahn]], [[The Codebreakers]], 1967, ISBN 0-684-83130-9.&lt;/ref&gt;
* [[Computational science|Scientific computing]] enabled practical evaluation of processes and situations of great complexity, as well as experimentation entirely by software. It also enabled advanced study of the mind, and mapping of the human genome became possible with the [[Human Genome Project]].&lt;ref name=&quot;bgu&quot;/&gt; [[Distributed computing]] projects such as [[Folding@home]] explore [[protein folding]].
* [[Algorithmic trading]] has increased the [[Economic efficiency|efficiency]] and [[Market liquidity|liquidity]] of financial markets by using [[artificial intelligence]], [[machine learning]], and other [[statistics|statistical]] and [[Numerical analysis|numerical]] techniques on a large scale.&lt;ref&gt;{{cite news|url=http://www.telegraph.co.uk/money/main.jhtml?xml=/money/2006/08/27/ccsoft27.xml |title=Black box traders are on the march |newspaper=The Telegraph |date=August 26, 2006 |deadurl=yes |archiveurl=https://web.archive.org/web/20080621070439/http://www.telegraph.co.uk/money/main.jhtml?xml=/money/2006/08/27/ccsoft27.xml |archivedate=June 21, 2008 }}&lt;/ref&gt; High frequency algorithmic trading can also exacerbate [[volatility (finance)|volatility]].&lt;ref&gt;{{cite web |ssrn=1686004 |title=The Impact of High Frequency Trading on an Electronic Market |doi=10.2139/ssrn.1686004 |publisher=Papers.ssrn.com |accessdate=2012-05-14}}&lt;/ref&gt;
* [[Computer graphics]] and [[computer-generated imagery]] have become ubiquitous in modern [[entertainment]], particularly in [[television]], [[Filmmaking|cinema]], [[advertising]], [[animation]] and [[video game]]s. Even films that feature no explicit [[computer-generated imagery|CGI]] are usually &quot;filmed&quot; now on [[digital camera]]s, or [[video editing|edited]] or [[Video post-processing|post-processed]] using a digital video editor.&lt;ref&gt;{{cite web|last1=Maly|first1=Timy|title=How Digital Filmmakers Produced a Gorgeous Sci-Fi Movie on a Kickstarter Budget|url=https://www.wired.com/2013/01/kickstarted-scifi-movie/|publisher=Wired|accessdate=November 24, 2015}}&lt;/ref&gt;&lt;ref&gt;{{cite web|last1=Matthau|first1=Charles|title=How Tech Has Shaped Film Making: The Film vs. Digital Debate Is Put to Rest|url=https://www.wired.com/insights/2015/01/how-tech-shaped-film-making/|publisher=Wired|accessdate=November 24, 2015}}&lt;/ref&gt;
* [[Simulation]] of various processes, including computational [[fluid dynamics]], physical, electrical, and electronic systems and circuits, as well as societies and social situations (notably war games) along with their habitats, among many others. Modern computers enable optimization of such designs as complete aircraft. Notable in electrical and electronic circuit design are [[SPICE]], as well as software for physical realization of new (or modified) designs. The latter includes essential design software for [[integrated circuit]]s.{{Citation needed|date=October 2010}}
* [[Artificial intelligence]] is becoming increasingly important as it gets more efficient and complex. There are many applications of AI, some of which can be seen at home, such as [[robotic vacuum cleaner]]s. It is also present in video games and on the modern battlefield in drones, anti-missile systems, and [[Legged Squad Support System|squad support robots]].
* [[Human-Computer Interaction]] combines novel algorithms with design strategies that enable rapid human performance, low error rates, ease in learning, and high satisfaction. Researchers use ethnographic observation and automated data collection to understand user needs, then conduct usability tests to refine designs. Key innovations include the [[direct manipulation]], selectable web links, [[touchscreen]] designs, mobile applications, and [[virtual reality]].

==Etymology==
{{see also|Informatics#Etymology}}

Although first proposed in 1956,&lt;ref name=&quot;Tedre2014&quot;/&gt; the term &quot;computer science&quot; appears in a 1959 article in ''[[Communications of the ACM]]'',&lt;ref name=&quot;Fine_1959&quot;&gt;
{{cite journal
 |author=Louis Fine
 |year=1959
 |title=The Role of the University in Computers, Data Processing, and Related Fields
 |journal=Communications of the ACM
 |volume=2 |issue=9 |pages=7–14
 |doi=10.1145/368424.368427
}}&lt;/ref&gt;
in which Louis Fein argues for the creation of a ''Graduate School in Computer Sciences'' analogous to the creation of [[Harvard Business School]] in 1921,&lt;ref&gt;{{cite web|title=Stanford University Oral History|url=http://library.stanford.edu/guides/stanford-university-oral-history|publisher=Stanford University|accessdate=May 30, 2013}}&lt;/ref&gt; justifying the name by arguing that, like [[management science]], the subject is applied and interdisciplinary in nature, while having the characteristics typical of an academic discipline.&lt;ref name=&quot;Fine_1959&quot;/&gt;
His efforts, and those of others such as [[numerical analysis|numerical analyst]] [[George Forsythe]], were rewarded: universities went on to create such programs, starting with Purdue in 1962.&lt;ref&gt;[[Donald Knuth]] (1972). ''[http://www.stanford.edu/dept/ICME/docs/history/forsythe_knuth.pdf &quot;George Forsythe and the Development of Computer Science&quot;]. ''Comms. ACM''. {{webarchive |url=https://web.archive.org/web/20131020200802/http://www.stanford.edu/dept/ICME/docs/history/forsythe_knuth.pdf |date=October 20, 2013 }}&lt;/ref&gt; Despite its name, a significant amount of computer science does not involve the study of computers themselves. Because of this, several alternative names have been proposed.&lt;ref&gt;{{cite web |author=Matti Tedre |date=2006 |url=http://epublications.uef.fi/pub/urn_isbn_952-458-867-6/urn_isbn_952-458-867-6.pdf |title=The Development of Computer Science: A Sociocultural Perspective |page=260 |accessdate=December 12, 2014}}&lt;/ref&gt; Certain departments of major universities prefer the term ''computing science'', to emphasize precisely that difference. Danish scientist [[Peter Naur]] suggested the term ''datalogy'',&lt;ref&gt;
{{cite journal
 |author=Peter Naur
 |year=1966
 |title=The science of datalogy
 |journal=Communications of the ACM
 |volume=9 |issue=7 |page=485
 |doi=10.1145/365719.366510
}}&lt;/ref&gt; to reflect the fact that the scientific discipline revolves around data and data treatment, while not necessarily involving computers. The first scientific institution to use the term was the Department of Datalogy at the University of Copenhagen, founded in 1969, with Peter Naur being the first professor in datalogy. The term is used mainly in the Scandinavian countries. An alternative term, also proposed by Naur, is [[data science]]; this is now used for a distinct field of data analysis, including statistics and databases.

Also, in the early days of computing, a number of terms for the practitioners of the field of computing were suggested in the ''Communications of the ACM''—''turingineer'', ''turologist'', ''flow-charts-man'', ''applied meta-mathematician'', and ''applied [[epistemology|epistemologist]]''.&lt;ref&gt;{{cite journal |title=Communications of the ACM |date=&lt;!-- missing! --&gt; |journal=Communications of the ACM |volume=1 |issue=4 |page=6| doi = 10.1145/368796.368802|last1=Weiss |first1=E. A. |last2=Corley |first2=Henry P. T. }}&lt;/ref&gt; Three months later in the same journal, ''comptologist'' was suggested, followed next year by ''hypologist''.&lt;ref&gt;Communications of the ACM 2(1):p.4&lt;/ref&gt; The term ''computics'' has also been suggested.&lt;ref&gt;IEEE Computer 28(12):p.136&lt;/ref&gt; {{anchor|Name of the field in Europe}}In Europe, terms derived from contracted translations of the expression &quot;automatic information&quot; (e.g. &quot;informazione automatica&quot; in Italian) or &quot;information and mathematics&quot; are often used, e.g. ''informatique'' (French), ''Informatik'' (German), ''informatica'' (Italian, Dutch), ''informática'' (Spanish, Portuguese), ''informatika'' ([[Slavic languages]] and [[Hungarian language|Hungarian]]) or ''pliroforiki'' (''πληροφορική'', which means informatics) in [[Greek language|Greek]]. Similar words have also been adopted in the UK (as in ''the School of Informatics of the University of Edinburgh'').&lt;ref&gt;P. Mounier-Kuhn, ''L'Informatique en France, de la seconde guerre mondiale au Plan Calcul. L'émergence d'une science'', Paris, PUPS, 2010, ch. 3 &amp; 4.&lt;/ref&gt;
&quot;In the U.S., however, [[informatics]] is linked with applied computing, or computing in the context of another domain.&quot;&lt;ref&gt;[http://cacm.acm.org/magazines/2010/2/69363-why-an-informatics-degree]&lt;/ref&gt;

A folkloric quotation, often attributed to—but almost certainly not first formulated by—[[Edsger W. Dijkstra|Edsger Dijkstra]], states that &quot;computer science is no more about computers than astronomy is about telescopes.&quot;&lt;ref group=note&gt;See the entry
&quot;[[q:Computer science|Computer science]]&quot; on Wikiquote for the history of this quotation.&lt;/ref&gt; The design and deployment of computers and computer systems is generally considered the province of disciplines other than computer science. For example, the study of [[computer hardware]] is usually considered part of [[computer engineering]], while the study of commercial [[computer system]]s and their deployment is often called [[information technology]] or [[information system]]s. However, there has been much cross-fertilization of ideas between the various computer-related disciplines. Computer science research also often intersects other disciplines, such as [[philosophy]], [[cognitive science]], [[computational linguistics|linguistics]], [[mathematics]], [[physics]], [[biology]], [[computational statistics|statistics]], and [[logic]].

Computer science is considered by some to have a much closer relationship with mathematics than many scientific disciplines, with some observers saying that computing is a mathematical science.&lt;ref name=&quot;Denning_cs_discipline&quot; /&gt; Early computer science was strongly influenced by the work of mathematicians such as [[Kurt Gödel]] and [[Alan Turing]], and there continues to be a useful interchange of ideas between the two fields in areas such as [[mathematical logic]], [[category theory]], [[domain theory]], and [[algebra]].&lt;ref name=&quot;Tedre2014&quot;/&gt;

The relationship between computer science and [[software engineering]] is a contentious issue, which is further muddied by [[Software engineer#Use of the title .22Engineer.22|disputes]] over what the term &quot;software engineering&quot; means, and how computer science is defined.&lt;ref&gt;{{Cite journal | last1 = Tedre | first1 = M. | title = Computing as a Science: A Survey of Competing Viewpoints | doi = 10.1007/s11023-011-9240-4 | journal = Minds and Machines | volume = 21 | issue = 3 | pages = 361–387 | year = 2011 | pmid =  | pmc = }}&lt;/ref&gt; [[David Parnas]], taking a cue from the relationship between other engineering and science disciplines, has claimed that the principal focus of computer science is studying the properties of computation in general, while the principal focus of software engineering is the design of specific computations to achieve practical goals, making the two separate but complementary disciplines.&lt;ref&gt;{{Cite journal | last1 = Parnas | first1 = D. L. | journal = Annals of Software Engineering | volume = 6 | pages = 19–37 | year = 1998 | doi = 10.1023/A:1018949113292|title=Software engineering programmes are not computer science programmes}}, p. 19: &quot;Rather than treat software engineering as a subfield of computer science, I treat it as an element of the set, Civil Engineering, Mechanical Engineering, Chemical Engineering, Electrical Engineering, […]&quot;&lt;/ref&gt;

The academic, political, and funding aspects of computer science tend to depend on whether a department formed with a mathematical emphasis or with an engineering emphasis. Computer science departments with a mathematics emphasis and with a numerical orientation consider alignment with [[computational science]]. Both types of departments tend to make efforts to bridge the field educationally if not across all research.

==Philosophy==
{{main article|Philosophy of computer science}}
A number of computer scientists have argued for the distinction of three separate paradigms in computer science. [[Peter Wegner]] argued that those paradigms are science, technology, and mathematics.&lt;ref&gt;{{cite conference |author=Wegner, P. |title=Research paradigms in computer science—Proceedings of the 2nd international Conference on Software Engineering |location=San Francisco, California, United States |date=October 13–15, 1976 |publisher=IEEE Computer Society Press, Los Alamitos, CA}}&lt;/ref&gt; [[Peter J. Denning|Peter Denning]]'s working group argued that they are theory, abstraction (modeling), and design.&lt;ref&gt;{{Cite journal | last1 = Denning | first1 = P. J. | last2 = Comer | first2 = D. E. | last3 = Gries | first3 = D. | last4 = Mulder | first4 = M. C. | last5 = Tucker | first5 = A. | last6 = Turner | first6 = A. J. | last7 = Young | first7 = P. R. | title = Computing as a discipline | journal = Communications of the ACM | volume = 32 | pages = 9–23 | date = Jan 1989 | month = | doi = 10.1145/63238.63239}}&lt;/ref&gt; Amnon H. Eden described them as the &quot;rationalist paradigm&quot; (which treats computer science as a branch of mathematics, which is prevalent in theoretical computer science, and mainly employs [[deductive reasoning]]), the &quot;technocratic paradigm&quot; (which might be found in [[engineering]] approaches, most prominently in [[software engineering]]), and the &quot;scientific paradigm&quot; (which approaches computer-related artifacts from the empirical perspective of [[natural science]]s, identifiable in some branches of [[artificial intelligence]]).&lt;ref&gt;{{Cite journal | first1 = A. H. | title = Three Paradigms of Computer Science | journal = [[Minds and Machines]] | last1 = Eden| volume = 17 | issue = 2 | year = 2007 | url = http://www.eden-study.org/articles/2007/three_paradigms_of_computer_science.pdf| doi = 10.1007/s11023-007-9060-8 | pages = 135–167}}&lt;/ref&gt;

==Areas of computer science==
{{further information|Outline of computer science}}
As a discipline, computer science spans a range of topics from theoretical studies of algorithms and the limits of computation to the practical issues of implementing computing systems in hardware and software.&lt;ref name=&quot;CSAB1997&quot;&gt;{{cite web|author=Computing Sciences Accreditation Board|title=Computer Science as a Profession|url=http://www.csab.org/comp_sci_profession.html |date=May 28, 1997| accessdate=2010-05-23 |archiveurl = https://web.archive.org/web/20080617030847/http://www.csab.org/comp_sci_profession.html |archivedate = 2008-06-17}}&lt;/ref&gt;&lt;ref&gt;{{cite book |author=Committee on the Fundamentals of Computer Science: Challenges and Opportunities, National Research Council |title=Computer Science: Reflections on the Field, Reflections from the Field|url=http://www.nap.edu/catalog.php?record_id=11106#toc|publisher=National Academies Press|isbn=978-0-309-09301-9|year=2004}}&lt;/ref&gt;
[[CSAB (professional organization)|CSAB]], formerly called ''Computing Sciences Accreditation Board''—which is made up of representatives of the [[Association for Computing Machinery]] (ACM), and the [[IEEE Computer Society]] (IEEE CS)&lt;ref&gt;{{cite web |url=http://www.csab.org/ |title=CSAB Leading Computer Education |publisher=CSAB |date=2011-08-03 |accessdate=2011-11-19}}&lt;/ref&gt;—identifies four areas that it considers crucial to the discipline of computer science: ''theory of computation'', ''algorithms and data structures'', ''programming methodology and languages'', and ''computer elements and architecture''. In addition to these four areas, CSAB also identifies fields such as software engineering, artificial intelligence, computer networking and communication, database systems, parallel computation, distributed computation, human–computer interaction, computer graphics, operating systems, and numerical and symbolic computation as being important areas of computer science.&lt;ref name=&quot;CSAB1997&quot;/&gt;

===Theoretical computer science===
{{main article|Theoretical computer science}}
''Theoretical Computer Science'' is mathematical and abstract in spirit, but it derives its motivation from practical and everyday computation. Its aim is to understand the nature of '''computation''' and, as a consequence of this understanding, provide more efficient methodologies. All papers introducing or studying mathematical, logic and formal concepts and methods are welcome, provided that their motivation is clearly drawn from the field of '''computing'''.

====Theory of computation====
{{main article|Theory of computation}}
According to [[Peter J. Denning|Peter Denning]], the fundamental question underlying computer science is, &quot;What can be (efficiently) automated?&quot;&lt;ref name=&quot;Denning_cs_discipline&quot;&gt;{{cite journal | last=Denning | first=Peter J. | authorlink=Peter J. Denning | year=2000 | title=Computer Science: The Discipline | url=http://www.idi.ntnu.no/emner/dif8916/denning.pdf | journal=Encyclopedia of Computer Science | format=PDF |archiveurl = https://web.archive.org/web/20060525195404/http://www.idi.ntnu.no/emner/dif8916/denning.pdf |archivedate = 2006-05-25}}&lt;/ref&gt; Theory of computation is focused on answering fundamental questions about what can be computed and what amount of resources are required to perform those computations. In an effort to answer the first question, [[computability theory]] examines which computational problems are solvable on various theoretical [[models of computation]]. The second question is addressed by [[computational complexity theory]], which studies the time and space costs associated with different approaches to solving a multitude of computational problems.

The famous [[P versus NP problem|P = NP?]] problem, one of the [[Millennium Prize Problems]],&lt;ref&gt;[http://www.claymath.org/millennium/P_vs_NP/ Clay Mathematics Institute] P = NP {{webarchive |url=https://web.archive.org/web/20131014194456/http://www.claymath.org/millennium/P_vs_NP/ |date=October 14, 2013 }}&lt;/ref&gt; is an open problem in the theory of computation.

{| style=&quot;border:1px solid #ccc; text-align:center; margin:auto;&quot; cellspacing=&quot;15&quot;
|-
| [[File:DFAexample.svg|96px]]
| [[File:Wang tiles.svg|96px]]
| '''P = NP?'''
| '''GNITIRW-TERCES'''
| [[File:Blochsphere.svg|96px]]
|-
| [[Automata theory]]
| [[Computability theory]]
| [[Computational complexity theory]]
| [[Cryptography]]
| [[Quantum computer|Quantum computing theory]]
|}

====Information and coding theory====
{{main article|Information theory|Coding theory}}
Information theory is related to the quantification of information. This was developed by [[Claude Shannon]] to find fundamental limits on [[signal processing]] operations such as compressing data and on reliably storing and communicating data.&lt;ref&gt;{{cite web |date=October 14, 2002 |last=P. Collins |first=Graham |title=Claude E. Shannon: Founder of Information Theory |url=http://www.scientificamerican.com/article.cfm?id=claude-e-shannon-founder |publisher=Scientific American |accessdate=December 12, 2014}}&lt;/ref&gt;
Coding theory is the study of the properties of [[code]]s (systems for converting information from one form to another) and their fitness for a specific application. Codes are used for [[data compression]], [[cryptography]], [[error detection and correction]], and more recently also for [[Linear network coding|network coding]]. Codes are studied for the purpose of designing efficient and reliable [[data transmission]] methods.

====Algorithms and data structures====
Algorithms and data structures is the study of commonly used computational methods and their computational efficiency.

{| style=&quot;border:1px solid #ccc; text-align:center; margin:auto;&quot; cellspacing=&quot;15&quot;
|-
| {{math|''O''(''n''&lt;sup&gt;2&lt;/sup&gt;)}}
| [[File:Sorting quicksort anim.gif|96px]]
| [[File:Singly linked list.png|96px]]
| [[File:TSP Deutschland 3.png|96px]]
| [[File:SimplexRangeSearching.svg|96px]]
|-
| [[Analysis of algorithms]]
| [[Algorithm]]s
| [[Data structures]]
| [[Combinatorial optimization]]
| [[Computational geometry]]
|}

====Programming language theory====
{{main article|Programming language theory}}
Programming language theory is a branch of computer science that deals with the design, implementation, analysis, characterization, and classification of [[programming language]]s and their individual [[Programming language#Elements|features]]. It falls within the discipline of computer science, both depending on and affecting [[mathematics]], [[software engineering]], and [[linguistics]]. It is an active research area, with numerous dedicated academic journals.

{| style=&quot;border:1px solid #ccc; text-align:center; margin:auto;&quot; cellspacing=&quot;15&quot;
|-
| &lt;math&gt;\Gamma\vdash x: \text{Int}&lt;/math&gt;
| [[File:Compiler.svg|96px]]
| [[File:Python add5 syntax.svg|96px]]
|-
| [[Type theory]]
| [[Compiler construction|Compiler design]]
| [[Programming language]]s
|}

====Formal methods====
{{main article|Formal methods}}
Formal methods are a particular kind of [[Mathematics|mathematically]] based technique for the [[formal specification|specification]], development and [[formal verification|verification]] of [[software]] and [[computer hardware|hardware]] systems. The use of formal methods for software and hardware design is motivated by the expectation that, as in other engineering disciplines, performing appropriate mathematical analysis can contribute to the reliability and robustness of a design. They form an important theoretical underpinning for software engineering, especially where safety or security is involved. Formal methods are a useful adjunct to software testing since they help avoid errors and can also give a framework for testing. For industrial use, tool support is required. However, the high cost of using formal methods means that they are usually only used in the development of high-integrity and [[life-critical system]]s, where [[safety]] or [[computer security|security]] is of utmost importance. Formal methods are best described as the application of a fairly broad variety of [[theoretical computer science]] fundamentals, in particular [[logic in computer science|logic]] calculi, [[formal language]]s, [[automata theory]], and [[program semantics]], but also [[type systems]] and [[algebraic data types]] to problems in software and hardware specification and verification.

===Applied computer science===
Applied computer science aims at identifying certain computer science concepts that can be used directly in solving real world problems.

====Artificial intelligence====
{{main article|Artificial intelligence}}
Artificial intelligence (AI) aims to or is required to synthesize goal-orientated processes such as problem-solving, decision-making, environmental adaptation, learning and communication found in humans and animals. From its origins in [[cybernetics]] and in the [[History of artificial intelligence|Dartmouth Conference]] (1956), artificial intelligence research has been necessarily cross-disciplinary, drawing on areas of expertise such as [[applied mathematics]], [[Mathematical logic|symbolic logic]], [[semiotics]], [[electrical engineering]], [[philosophy of mind]], [[neurophysiology]], and [[social intelligence]]. AI is associated in the popular mind with [[Robotics|robotic development]], but the main field of practical application has been as an embedded component in areas of [[software development]], which require computational understanding. The starting-point in the late 1940s was [[Alan Turing]]'s question &quot;Can computers think?&quot;, and the question remains effectively unanswered although the [[Turing test]] is still used to assess computer output on the scale of human intelligence. But the automation of evaluative and predictive tasks has been increasingly successful as a substitute for human monitoring and intervention in domains of computer application involving complex real-world data.

{| style=&quot;border:1px solid #ccc; text-align:center; margin:auto;&quot; cellspacing=&quot;15&quot;
|-
| [[File:Nicolas P. Rougier's rendering of the human brain.png|96px]]
| [[File:Human eye, rendered from Eye.png|96px]]
| [[File:Corner.png|96px]]
|-
| [[Machine learning]]
| [[Computer vision]]
| [[Image processing]]
|-
| [[File:KnnClassification.svg|96px]]
| [[File:Julia iteration data.png|96px]]
| [[File:sky.png|96px]]
|-
| [[Pattern recognition]]
| [[Data mining]]
| [[Evolutionary computation]]
|-
| [[File:neuron.svg|96px]]
| [[File:english.png|96px]]
| [[File:HONDA ASIMO.jpg|64px]]
|-
| [[Knowledge representation]]
| [[Natural language processing]]
| [[Robotics]]
|}

====Computer architecture and engineering====
{{main article|Computer architecture|Computer engineering}}
Computer architecture, or digital computer organization, is the conceptual design and fundamental operational structure of a computer system. It focuses largely on the way by which the central processing unit performs internally and accesses addresses in memory.&lt;ref&gt;{{cite web|last=A. Thisted|first=Ronald|title=Computer Architecture |url=http://galton.uchicago.edu/~thisted/Distribute/comparch.pdf|publisher=The University of Chicago|date=April 7, 1997}}&lt;/ref&gt; The field often involves disciplines of computer engineering and electrical engineering, selecting and interconnecting hardware components to create computers that meet functional, performance, and cost goals.

{| style=&quot;border:1px solid #ccc; text-align:center; margin:auto;&quot; cellspacing=&quot;15&quot;
|-
| [[File:NOR ANSI.svg|96px]]
| [[File:Fivestagespipeline.png|96px]]
| [[File:SIMD.svg|96px]]
|-
| [[Boolean algebra|Digital logic]]
| [[Microarchitecture]]
| [[Multiprocessing]]
|-
| [[File:Roomba original.jpg|96px]]
| [[File:flowchart.png|96px]]
| [[File:Operating system placement.svg|96px]]
|-
| [[Ubiquitous computing]]
| [[Systems architecture]]
| [[Operating system]]s
|}

====Computer performance analysis====
{{main article|Computer performance}}
Computer performance analysis is the study of work flowing through computers with the general goals of improving [[throughput]], controlling [[Response time (technology)|response time]], using resources efficiently, eliminating [[bottleneck (software)|bottleneck]]s, and predicting performance under anticipated peak loads.&lt;ref&gt;{{cite book | last = Wescott | first = Bob | title = The Every Computer Performance Book, Chapter 3: Useful laws  | publisher = [[CreateSpace]] | date = 2013 | isbn = 1482657759}}&lt;/ref&gt;

====Computer graphics and visualization====
{{main article|Computer graphics (computer science)}}
Computer graphics is the study of digital visual contents, and involves synthesis and manipulation of image data. The study is connected to many other fields in computer science, including [[computer vision]], [[image processing]], and [[computational geometry]], and is heavily applied in the fields of [[special effects]] and [[video games]].

====Computer security and cryptography====
{{main article|Computer security|Cryptography}}
Computer security is a branch of computer technology, whose objective includes protection of information from unauthorized access, disruption, or modification while maintaining the accessibility and usability of the system for its intended users. Cryptography is the practice and study of hiding (encryption) and therefore deciphering (decryption) information. Modern cryptography is largely related to computer science, for many encryption and decryption algorithms are based on their computational complexity.

====Computational science====
[[Computational science]] (or [[scientific computing]]) is the field of study concerned with constructing [[scientific modelling|mathematical models]] and [[numerical analysis|quantitative analysis]] techniques and using computers to analyze and solve [[Science|scientific]] problems. In practical use, it is typically the application of [[computer simulation]] and other forms of [[computation]] to problems in various scientific disciplines.

{| style=&quot;border:1px solid #ccc; text-align:center; margin:auto;&quot; cellspacing=&quot;15&quot;
|-
| [[File:Lorenz attractor yb.svg|96px]]
| [[File:Quark wiki.jpg|96px]]
| [[File:Naphthalene-3D-balls.png|96px]]
| [[File:1u04-argonaute.png|96px]]
|-
| [[Numerical analysis]]
| [[Computational physics]]
| [[Computational chemistry]]
| [[Bioinformatics]]
|}

====Computer networks====
{{main article|Computer network}}
This branch of computer science aims to manage networks between computers worldwide.

====Concurrent, parallel and distributed systems====
{{main article|Concurrency (computer science)|Distributed computing}}
Concurrency is a property of systems in which several computations are executing simultaneously, and potentially interacting with each other. A number of mathematical models have been developed for general concurrent computation including [[Petri net]]s, [[Process calculus|process calculi]] and the [[Parallel random-access machine|Parallel Random Access Machine]] model. A distributed system extends the idea of concurrency onto multiple computers connected through a network. Computers within the same distributed system have their own private memory, and information is often exchanged among themselves to achieve a common goal.

====Databases====
{{main article|Database}}
A database is intended to organize, store, and retrieve large amounts of data easily. Digital databases are managed using database management systems to store, create, maintain, and search data, through [[database model]]s and [[query language]]s.

====Human-computer interaction====
{{main article|Human-computer interaction}}
Research that develops theories, principles, and guidelines for user interface designers, so they can create satisfactory user experiences with desktop, laptop, and mobile devices.

====Software engineering====
{{main article|Software engineering}}
{{see also|Computer programming}}
Software engineering is the study of designing, implementing, and modifying software in order to ensure it is of high quality, affordable, maintainable, and fast to build. It is a systematic approach to software design, involving the application of engineering practices to software. Software engineering deals with the organizing and analyzing of software—it doesn't just deal with the creation or manufacture of new software, but its internal maintenance and arrangement. Both computer applications software engineers and computer systems software engineers are projected to be among the fastest growing occupations from 2008 to 2018.

==The great insights of computer science==
The philosopher of computing [[William J. Rapaport|Bill Rapaport]] noted three ''Great Insights of Computer Science'':&lt;ref&gt;{{cite web|url=http://www.cse.buffalo.edu/~rapaport/computation.html|title=What Is Computation?|work=buffalo.edu}}&lt;/ref&gt;
* [[Gottfried Wilhelm Leibniz]]'s, [[George Boole]]'s, [[Alan Turing]]'s, [[Claude Shannon]]'s, and [[Samuel Morse]]'s insight: there are only ''two objects'' that a computer has to deal with in order to represent &quot;anything&quot;.
:: All the information about any computable problem can be represented using only 0 and 1 (or any other bistable pair that can flip-flop between two easily distinguishable states, such as &quot;on/off&quot;, &quot;magnetized/de-magnetized&quot;, &quot;high-voltage/low-voltage&quot;, etc.).
{{see also|Digital physics}}
* [[Alan Turing]]'s insight: there are only ''five actions'' that a computer has to perform in order to do &quot;anything&quot;.
:: Every algorithm can be expressed in a language for a computer consisting of only five basic instructions:
::* move left one location;
::* move right one location;
::* read symbol at current location;
::* print 0 at current location;
::* print 1 at current location.
{{see also|Turing machine}}
* [[Corrado Böhm]] and [[Giuseppe Jacopini]]'s insight: there are only ''three ways of combining'' these actions (into more complex ones) that are needed in order for a computer to do &quot;anything&quot;.
:: Only three rules are needed to combine any set of basic instructions into more complex ones:
::* ''sequence'': first do this, then do that;
::* '' selection'': IF such-and-such is the case, THEN do this, ELSE do that;
::* ''repetition'': WHILE such-and-such is the case DO this.
:: Note that the three rules of Boehm's and Jacopini's insight can be further simplified with the use of [[goto]] (which means it is more elementary than [[structured programming]]).
{{see also|Elementary function arithmetic#Friedman's grand conjecture}}

==Academia==
{{further information|List of computer science conferences|Category:Computer science journals}}
Conferences are important events for computer science research. During these conferences, researchers from the public and private sectors present their recent work and meet. Unlike in most other academic fields, in computer science, the prestige of [[proceedings|conference papers]] is greater than that of journal publications.&lt;ref&gt;{{cite journal|last1=Meyer|first1=Bertrand|title=Viewpoint: Research evaluation for computer science|journal=Communications of the ACM|date=April 2009|volume=25|issue=4|pages=31–34|doi=10.1145/1498765.1498780}}&lt;/ref&gt;&lt;ref&gt;{{cite web|last1=Patterson|first1=David|title=Evaluating Computer Scientists and Engineers For Promotion and Tenure|url=http://cra.org/resources/bp-view/evaluating_computer_scientists_and_engineers_for_promotion_and_tenure/|publisher=Computing Research Association|date=August 1999}}&lt;/ref&gt; One proposed explanation for this is the quick development of this relatively new field requires rapid review and distribution of results, a task better handled by conferences than by journals.&lt;ref&gt;{{cite journal|last1=Fortnow|first1=Lance|title=Viewpoint: Time for Computer Science to Grow Up|journal=Communications of the ACM|date=August 2009|volume=52|issue=8|pages=33–35|doi=10.1145/1536616.1536631|url=http://cacm.acm.org/magazines/2009/8/34492-viewpoint-time-for-computer-science-to-grow-up/fulltext}}&lt;/ref&gt;

==Education==
Since computer science is a relatively new field, it is not as widely taught in schools and universities as other academic subjects. For example, in 2014, [[Code.org]] estimated that only 10 percent of high schools in the United States offered computer science education.&lt;ref&gt;{{cite news|title=Computer Science: Not Just an Elective Anymore|url=http://www.edweek.org/ew/articles/2014/02/26/22computer_ep.h33.html|work=Education Week|date=February 25, 2014}}&lt;/ref&gt; A 2010 report by Association for Computing Machinery (ACM) and Computer Science Teachers Association (CSTA) revealed that only 14 out of 50 states have adopted significant education standards for high school computer science.&lt;ref&gt;{{cite web|title=Running On Empty|url=http://runningonempty.acm.org/fullreport2.pdf | date= October 2010}}&lt;/ref&gt; However, computer science education is growing.&lt;ref&gt;{{Cite web|url=http://blog.stephenwolfram.com/2016/09/how-to-teach-computational-thinking/|title=How to Teach Computational Thinking—Stephen Wolfram Blog|website=blog.stephenwolfram.com|access-date=2016-09-16}}&lt;/ref&gt; Some countries, such as Israel, New Zealand and South Korea, have already included computer science in their respective national secondary education curriculum.&lt;ref&gt;{{cite news|title=A is for algorithm|url=http://www.economist.com/news/international/21601250-global-push-more-computer-science-classrooms-starting-bear-fruit|work=The Economist|date=April 26, 2014}}&lt;/ref&gt;&lt;ref&gt;{{cite web|title=Computing at School International comparisons|url=http://www.computingatschool.org.uk/data/uploads/internationalcomparisons-v5.pdf|accessdate=20 July 2015}}&lt;/ref&gt; Several countries are following suit.&lt;ref name=HEA_STEM_SG13&gt;{{cite conference |url=https://www.academia.edu/2390480/Educating_Programmers_A_Reflection_on_Barriers_to_Deliberate_Practice |title=Educating Programmers: A Reflection on Barriers to Deliberate Practice |first1=Michael |last1=Scott |first2=Gheorghita |last2=Ghinea |format=pdf |conference=Proceedings of the 2nd HEA Conference on Learning and Teaching in STEM Disciplines |publisher=HEA |pages=85–90 |doi=10.11120/stem.hea.2013.0005 |date=17 April 2013 |accessdate=March 25, 2016}}&lt;/ref&gt;&lt;ref&gt;{{cite news|title=Adding Coding to the Curriculum|url=https://www.nytimes.com/2014/03/24/world/europe/adding-coding-to-the-curriculum.html|work=New York Times|date=March 23, 2014}}&lt;/ref&gt;

In most countries, there is a significant gender gap in computer science education. For example, in the US about 20% of computer science degrees in 2012 were conferred to women.&lt;ref&gt;{{cite web|title=IT gender gap: Where are the female programmers?|url=http://www.randalolson.com/2014/06/14/percentage-of-bachelors-degrees-conferred-to-women-by-major-1970-2012/|accessdate=20 July 2015}}&lt;/ref&gt; This gender gap also exists in other Western countries.&lt;ref name=&quot;gender&quot;&gt;{{cite web|title=IT gender gap: Where are the female programmers?|url=http://www.techrepublic.com/blog/software-engineer/it-gender-gap-where-are-the-female-programmers/}}&lt;/ref&gt; However, in some parts of the world, the gap is small or nonexistent. In 2011, approximately half of all computer science degrees in [[Malaysia]] were conferred to women.&lt;ref&gt;{{cite web|title=what gender is science|url=http://www.soc.ucsb.edu/faculty/mariacharles/documents/WhatGenderisScience.pdf|accessdate=20 July 2015}}&lt;/ref&gt; In 2001, women made up 54.5% of computer science graduates in [[Guyana]].&lt;ref name=&quot;gender&quot;/&gt;

==See also==
{{main article|Outline of computer science}}
{{portal|Computer science}}
{{colbegin|2}}
* [[Academic genealogy of computer scientists]]
* [[Association for Computing Machinery]]
* [[Computer Science Teachers Association]]
* [[Informatics]] and [[Engineering informatics]]
* [[List of academic computer science departments]]
* [[List of computer scientists]]
* [[List of important publications in computer science|List of publications in computer science]]
* [[List of pioneers in computer science]]
* [[List of unsolved problems in computer science]]
* [[Outline of software engineering]]
* [[Technology transfer in computer science]]
* [[Turing Award]]
{{Books-inline|Computer science}}
{{colend}}

==Notes==
{{reflist|group=note}}

==References==
{{reflist|30em}}

==Further reading==
{{refbegin|30em}}
; Overview
* {{cite book|first=Allen B.|last=Tucker|authorlink=Allen B. Tucker|title=Computer Science Handbook|edition=2nd|publisher=Chapman and Hall/CRC|year=2004|isbn=1-58488-360-X}}
** &quot;Within more than 70 chapters, every one new or significantly revised, one can find any kind of information and references about computer science one can imagine. […] all in all, there is absolute nothing about Computer Science that can not be found in the 2.5 kilogram-encyclopaedia with its 110 survey articles […].&quot; (Christoph Meinel, ''[[Zentralblatt MATH]]'')
* {{cite book|first=Jan|last=van Leeuwen|authorlink=Jan van Leeuwen|title=Handbook of Theoretical Computer Science|publisher=The MIT Press|year=1994|isbn=0-262-72020-5}}
** &quot;[…] this set is the most unique and possibly the most useful to the [theoretical computer science] community, in support both of teaching and research […]. The books can be used by anyone wanting simply to gain an understanding of one of these areas, or by someone desiring to be in research in a topic, or by instructors wishing to find timely information on a subject they are teaching outside their major areas of expertise.&quot; (Rocky Ross, ''[[SIGACT News]]'')
* {{cite book|title=Encyclopedia of Computer Science|edition=4th|first1=Anthony|last1=Ralston|authorlink=Anthony Ralston|first2=Edwin D.|last2=Reilly|authorlink2=Edwin D. Reilly|first3=David|last3=Hemmendinger|authorlink3=David Hemmendinger|publisher=Grove's Dictionaries|year=2000|isbn=1-56159-248-X|url=http://portal.acm.org/ralston.cfm}}
** &quot;Since 1976, this has been the definitive reference work on computer, computing, and computer science. […] Alphabetically arranged and classified into broad subject areas, the entries cover hardware, computer systems, information and data, software, the mathematics of computing, theory of computation, methodologies, applications, and computing milieu. The editors have done a commendable job of blending historical perspective and practical reference information. The encyclopedia remains essential for most public and academic library reference collections.&quot; (Joe Accardin, Northeastern Illinois Univ., Chicago)
* {{cite book|url=https://books.google.com/books?id=JTYPKxug49IC&amp;printsec=frontcover#v=onepage&amp;q&amp;f=false|title=Milestones in Computer Science and Information Technology|author=Edwin D. Reilly| publisher=Greenwood Publishing Group|year=2003|isbn=978-1-57356-521-9}}
;Selected literature
* {{cite book|first=Donald E.|last=Knuth|authorlink=Donald Knuth|title=Selected Papers on Computer Science|publisher=CSLI Publications, [[Cambridge University Press]]|year=1996}}
* {{cite book|ref=COLLIER|last=Collier|first=Bruce|title=The little engine that could've: The calculating machines of Charles Babbage|publisher=Garland Publishing Inc|isbn=0-8240-0043-9|url=http://robroy.dyndns.info/collier/index.html}}
* {{cite book|ref=HAIKEN|first=Bernard|last=Cohen|title=Howard Aiken, Portrait of a computer pioneer|publisher=The MIT press|year=2000|isbn=978-0-2625317-9-5}}
* {{cite book|first=Matti|last=Tedre|title=The Science of Computing: Shaping a Discipline|publisher=CRC Press, [[Taylor &amp; Francis]]|year=2014}}
* {{cite book|title=The origins of Digital computers, Selected Papers|last=Randell|first=Brian|author-link=Brian Randell |year=1973|publisher=Springer-Verlag|isbn=3-540-06169-X}}
** &quot;Covering a period from 1966 to 1993, its interest lies not only in the content of each of these papers — still timely today — but also in their being put together so that ideas expressed at different times complement each other nicely.&quot; (N. Bernard, ''Zentralblatt MATH'')
;Articles
* Peter J. Denning. ''[http://portal.acm.org/citation.cfm?id=1053309&amp;coll=&amp;dl=ACM&amp;CFID=15151515&amp;CFTOKEN=6184618 Is computer science science?]'', Communications of the ACM, April 2005.
* Peter J. Denning, ''[http://portal.acm.org/citation.cfm?id=971303&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618 Great principles in computing curricula]'', Technical Symposium on Computer Science Education, 2004.
* Research evaluation for computer science, Informatics Europe [http://www.eqanie.eu/media/Como%20Conference/Tanca-Research_Assessment_A_new_Initiative_by_Informatics_Europe.pdf report]. Shorter journal version: Bertrand Meyer, Christine Choppy, Jan van Leeuwen and Jorgen Staunstrup, ''Research evaluation for computer science'', in [[Communications of the ACM]], vol. 52, no. 4, pp.&amp;nbsp;31–34, April 2009.
; Curriculum and classification
* [[Association for Computing Machinery]]. [http://www.acm.org/class/1998/overview.html 1998 ACM Computing Classification System]. 1998.
* Joint Task Force of Association for Computing Machinery (ACM), [[Association for Information Systems]] (AIS) and [[IEEE Computer Society]] (IEEE CS). [http://www.acm.org/education/curric_vols/CC2005-March06Final.pdf Computing Curricula 2005: The Overview Report]. September 30, 2005.
* [[Norman Gibbs]], [[Allen Tucker]]. &quot;A model curriculum for a liberal arts degree in computer science&quot;. ''Communications of the ACM'', Volume 29 Issue 3, March 1986.
{{refend}}

==External links==
{{Sister project links}}
{{Library resources box}}
* {{dmoz|Computers/Computer_Science/}}
* [http://www.lib.uwaterloo.ca/society/compsci_soc.html Scholarly Societies in Computer Science]
* [https://www.youtube.com/watch?v=fjMU-km-Cso What is Computer Science?]
* [http://jeffhuang.com/best_paper_awards.html Best Papers Awards in Computer Science since 1996]
* [http://se.ethz.ch/~meyer/gallery/ Photographs of computer scientists] by [[Bertrand Meyer]]
* [http://www.eecs.berkeley.edu/department/history.shtml EECS.berkeley.edu]
; Bibliography and academic search engines
* [http://citeseerx.ist.psu.edu/ CiteSeer&lt;sup&gt;''x''&lt;/sup&gt;] ([[CiteSeerX|article]]): search engine, digital library and repository for scientific and academic papers with a focus on computer and information science.
* [http://dblp.uni-trier.de/ DBLP Computer Science Bibliography] ([[Digital Bibliography &amp; Library Project|article]]): computer science bibliography website hosted at Universität Trier, in Germany.
* [http://liinwww.ira.uka.de/bibliography/ The Collection of Computer Science Bibliographies] ([[Collection of Computer Science Bibliographies|article]])
; Professional organizations
* [http://www.acm.org/ Association for Computing Machinery]
* [http://www.computer.org/ IEEE Computer Society]
* [http://www.informatics-europe.org/ Informatics Europe]
* [http://www.aaai.org/home.html AAAI]
* [http://membercentral.aaas.org/categories/computer-science AAAS Computer Science]
; Misc
* [http://cs.stackexchange.com/ Computer Science—Stack Exchange]: a community-run question-and-answer site for computer science
* [http://www.cs.bu.edu/AboutCS/WhatIsCS.pdf What is computer science]
* [http://www.cs.mtu.edu/~john/jenning.pdf Is computer science science?]
* [https://www.researchgate.net/publication/306078165_Computer_Science_Software_Must_be_Considered_as_an_Independent_Discipline_Computer_Science_Software_must_not_be_Treated_as_a_Sub-Domain_or_Subset_of_Mathematics Computer Science (Software) Must be Considered as an Independent Discipline.]

{{Software engineering}}
{{Computer science}}
{{Technology}}

{{Authority control}}

[[Category:Electrical engineering]]
[[Category:Electronic engineering]]
[[Category:Computer engineering]]
[[Category:Computer science| ]]</text>
      <sha1>cqggdxipntbkbhm7oqus3m05s0pq021</sha1>
    </revision>
  </page>
  <page>
    <title>Information and Computer Science</title>
    <ns>0</ns>
    <id>8431748</id>
    <revision>
      <id>767836749</id>
      <parentid>754284148</parentid>
      <timestamp>2017-02-28T06:36:37Z</timestamp>
      <contributor>
        <username>Tpark090</username>
        <id>30360884</id>
      </contributor>
      <comment>/* Employment */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13237">{{refimprove|date=November 2015}}
{{original synthesis|date=June 2016}}
[[File:CISLab.jpg|thumb|393x393px|A lab in which CIS is studied.]]
'''Information and Computer Science''' (ICS) or '''Computer and Information Science''' (CIS) (plural forms, i.e. ''Sciences'', may also be used) is a field that emphasizes ''both'' [[computing]] and [[Informatics (academic field)|informatics]], upholding the strong association between the fields of [[information science]]s and [[computer science]]s and treating [[computers]] as a tool rather than a field.

'''Information science''' is one with a [[Information science#Early beginnings|long history]], unlike the – relatively – [[History of computer science|very young]] field of computer science, and is primarily concerned with gathering, storing, disseminating, sharing and protecting any and all forms of information. It is a broad field, covering a myriad of different areas but is often referenced alongside computer science because of the incredibly useful nature of computers and computer programs in helping those studying and doing research in the field – particularly in helping to analyse data&lt;ref&gt;http://www.anderson.ucla.edu/faculty/jason.frand/teacher/technologies/palace/datamining.htm&lt;/ref&gt; and in spotting patterns too broad for a human to intuitively perceive. While information science is sometimes confused with information theory the two have vastly different subject matter. Information theory focuses on one particular mathematical concept of information while information science is focused on all aspects of the processes and techniques of information.

'''Computer science''', on the other hand, is less focused on information and its different states, but more, in a very broad sense, on the use of computers – both in theory and practice – to design and implement algorithms in order to aid the processing of information during the different states described above. It has strong foundations in the field of mathematics, as the very first recognised practitioners of the field were renowned mathematicians such as [[Alan Turing]].

Information Science and computing began to converge in the 1950s and 1960s, as information scientists started to realize the many ways computers would improve information storage and retrieval.

==Terminology==
Due to the distinction between computers and computing, some research groups refer to &quot;computing&quot; or &quot;Datalogy&quot;. The French refer to computer science as ''[[:fr:Informatique|informatique]]''. The term &quot;information and communications technology&quot;, or ICT, refers to how humans communicate with using machines and computers, making a distinction from &quot;information and computer science&quot;, which is how computers use and gain information.

Informatics is also distinct from &quot;computer science,&quot; which encompasses the study of logic and low-level computing issues.

==Education==
Universities may confer degrees of ICS and CIS, not to be confused with a more specific [[Bachelor of Computer Science]] or respective graduate Computer Science degrees.

The QS World University Rankings is one of the most widely recognised and distinguished university comparisons. They ranked the top 10 universities for Computer Science and Information Systems in 2015. They are:
*Massachusetts Institute of Technology(MIT)
*Stanford University
*University of Oxford
*Carnegie Mellon University
*Harvard University
*University of California, Berkeley(UCB)
*University of Cambridge
*The Hong Kong University of Science and Technology
*ETH Zurich – Swiss Federal Institute of Technology
*Princeton University&lt;ref&gt;{{Cite web|url = http://www.topuniversities.com/university-rankings/university-subject-rankings/2015/computer-science-information-systems#sorting=rank+region=+country=+faculty=+stars=false+search=|title = QS World University Rankings by Subject 2015 - Computer Science &amp; Information Systems|date = |accessdate = |website = |publisher = |last = |first = }}&lt;/ref&gt;

A Computer Information Science degree gives students both network and computing knowledge which is needed to design, develop, and assist information systems which helps to solve business problems and to support business problems and to support business operations and decision making at a managerial level also. &lt;ref&gt;{{Cite web|title = The 10 Best Online Bachelor in Computer Information Systems Degree Programs|url = http://www.thebestschools.org/rankings/10-best-online-bachelor-computer-information-systems-degree-programs/|website = Best Schools|accessdate = 2015-11-19}}&lt;/ref&gt;

== Areas of Information and Computer Science ==
Due the nature of this field, many topics are also shared with Computer Science and Information Systems fields.

The discipline of '''Information and Computer Science''' spans a vast range of areas from basic Computer Science theory (Algorithms and Computational Logic)  to in depth analysis of data manipulation and use within technology.&lt;ref&gt;{{Cite web|url = https://www.cs.mtu.edu/~john/whatiscs.html|title = What is Computer Science?|date = |accessdate = |website = |publisher = |last = |first = }}&lt;/ref&gt;

=== Programming Theory ===
The process of taking a given algorithm and encoding it into a language that can be understood and executed by a computer. There are many different types of programming languages and various different types of computers, however, they all have the same goal: to turn algorithms into machine code.&lt;ref&gt;{{Cite web|title = What Is Programming? — Problem Solving with Algorithms and Data Structures|url = http://interactivepython.org/runestone/static/pythonds/Introduction/WhatIsProgramming.html|website = interactivepython.org|accessdate = 2015-11-19}}&lt;/ref&gt;

Popular programming languages used within the academic study of CIS include, but are not limited to;
* Java
* Python
* C#
* C++
* Perl
* Ruby
* Pascal
* Swift
* Visual Basic

=== Information and Information Systems ===
The academic study of software and hardware systems that process large quantities and data, support large scale data management and how data can be used.&lt;ref&gt;{{Cite web|title = information system|url = http://www.britannica.com/topic/information-system|website = Encyclopedia Britannica|accessdate = 2015-11-19}}&lt;/ref&gt; This is where the field is unique from the standard study of Computer Science. The area of information systems focuses on the networks of hardware and software that are required to process, manipulate and distribute such data.

=== Computer Systems and Organisations ===
The process of analysing computer architecture and various logic circuits. This involves looking at low level computer processes at bit level computation. This is an in-depth look into the hardware processing of a computational system, involving looking at the basic structure of a computer and designing such systems.&lt;ref&gt;{{Cite web|title = What is Computer Architecture? - Definition from Techopedia|url = https://www.techopedia.com/definition/26757/computer-architecture|website = Techopedia.com|accessdate = 2015-11-19}}&lt;/ref&gt; This can also involve evaluating complex circuit diagrams, and being able to construct these to solve a main problem.

The main purpose behind this area of study is to achieve an understanding of how computers function on a basic level, often through tracing machine operations.

=== Machines, Languages and Computation ===
This is the study into fundamental computer algorithms, which are the basis to computer programs. Without algorithms, there would be no computer programs.&lt;ref&gt;{{Cite web|title = What is a computer algorithm?|url = http://computer.howstuffworks.com/question717.htm|website = HowStuffWorks|accessdate = 2015-11-19}}&lt;/ref&gt; This also involves the process of looking into various mathematical functions behind computational algorithms, basic theory and functional (low level) programming.

In an academic setting this area would introduce the fundamental mathematical theorems and functions behind theoretical computer science which are the building blocks for other areas in the field. Complex topics such as; proofs, algebraic functions and sets will be introduced during studies of CIS.

== Developments ==
Information and Computer Science is a field that is rapidly developing with job prospects for students being extremely promising with 75.7% of graduates gaining employment.&lt;ref&gt;{{Cite web|title = What can I do With My Degree?|url = http://www.prospects.ac.uk/options_computer_science.htm|website = Prospects|accessdate = 2015-11-19}}&lt;/ref&gt; Also the IT industry employs one in twenty of the workforce with it predicted to increase nearly five times faster than the average of the UK and between 2012 and 2017 more than half a million people will be needed within the industry and the fact that nine out of ten tech firms are suffering from candidate shortages which is having a negative impact on their companies as it delays the development of new products being created&lt;ref&gt;{{Cite web|title = Computer science graduates: why do they top unemployment tables?|url = https://www.theguardian.com/higher-education-network/blog/2013/sep/16/computer-science-graduates-unemployment-bme|website = The Guardian|accessdate = 2015-11-19}}&lt;/ref&gt; and it’s predicted in the US that in the next decade there will be more than one million jobs in the technology sector than computer science graduates to actually fill them.&lt;ref&gt;{{Cite web|title = A Push to Boost Computer Science Learning Even at an Early Age|url = http://www.npr.org/sections/alltechconsidered/2014/02/17/271151462/a-push-to-boost-computer-science-learning-even-at-an-early-age|website = NPR|accessdate = 2015-11-19}}&lt;/ref&gt; Because of this programming is now being taught at an earlier age with an aim to interest students from a young age into Computer and Information Science hopefully leading more children to study this at a higher level. For example, children in England will now be exposed to computer programming at the age of 5 due to an updated national curriculum.&lt;ref&gt;{{Cite web|title = Teaching our children to code: a quiet revolution
|url = http://www.telegraph.co.uk/technology/news/10410036/Teaching-our-children-to-code-a-quiet-revolution.html|website = The Telegraph|accessdate = 2015-11-19}}&lt;/ref&gt;

==Employment==
Due to the wide variety of jobs that now involve computer and information science related tasks it is difficult to provide a comprehensive list of possible jobs in this area, but some of the key areas are artificial intelligence, software engineering and computer networking/communication. Work in this area also tends to require sufficient understanding of mathematics and science.&lt;ref&gt;{{Cite web|title = What is Computer Science|url = https://www.cs.mtu.edu/~john/whatiscs.html|accessdate = 2015-11-19}}&lt;/ref&gt; Moreover, jobs that having a CIS degree can lead to, include- systems analyst, network administrator, system architect, information systems developer, web programmer, or software developer.&lt;ref&gt;{{Cite web|title = The 10 Best Online Bachelor in Computer Information Systems Degree Program
|url =http://www.thebestschools.org/rankings/10-best-online-bachelor-computer-information-systems-degree-programs/|website = The Best Schools|accessdate = 2015-11-19}}&lt;/ref&gt;

The earning potential for CIS graduates is quite promising. A 2013 survey from the National Association of Colleges and Employers (NACE) found that the average starting salary for graduates who earned a degree in a computer related field was $59,977, up 4.3% from the previous year. This is higher than other popular degrees such as Business ($54,234), education ($40,480) and Math and Sciences ($42,724).&lt;ref&gt;{{Cite web|title = Starting Salaries for New College Graduates|url = http://www.naceweb.org/uploadedFiles/NACEWeb/Research/Salary_Survey/Reports/salary-survey-april-2013-executive-summary.pdf|accessdate = 2015-11-26}}&lt;/ref&gt; Furthermore, Payscale ranked 129 college degrees based on their graduates earning potential with engineering, math, science, and technology fields dominating the ranking. With eight computer related degrees appearing among the top 30. With the lowest starting salary for these jobs being $49,900. &lt;ref&gt;{{Cite web|title = Computer science major ranks No. 8 for salary potential
|url = http://www.networkworld.com/article/2169997/data-center/computer-science-major-ranks-no--8-for-salary-potential.htm|website = Network World|accessdate = 2015-11-19}}&lt;/ref&gt; A Rasmussen College article describes various jobs CIS graduates may obtain with software applications developers at the top making a median income of  $98,260. &lt;ref&gt;{{Cite web|url=http://www.rasmussen.edu/degrees/technology/blog/entry-level-computer-science-jobs/|title=8 Entry-Level Computer Science Jobs that are ACTUALLY Hiring!|website=www.rasmussen.edu|access-date=2017-02-28}}&lt;/ref&gt;

According to the National Careers Service an Information Scientist can expect to earn £24,000+ per year as a starting salary.&lt;ref&gt;{{Cite web|title = Job Titles - Information Scientist|url = https://nationalcareersservice.direct.gov.uk/advice/planning/jobprofiles/Pages/informationscientist.aspx |accessdate = 2015-12-10}}&lt;/ref&gt;

==References==

&lt;references/&gt;

[[Category:Information science]]
[[Category:Computer science]]</text>
      <sha1>hr800aor56cquemv8rfgmqugkehr5q2</sha1>
    </revision>
  </page>
  <page>
    <title>Category:Computational geometry</title>
    <ns>14</ns>
    <id>25230402</id>
    <revision>
      <id>748820063</id>
      <parentid>707668273</parentid>
      <timestamp>2016-11-10T15:59:14Z</timestamp>
      <contributor>
        <username>Pleasantville</username>
        <id>3058640</id>
      </contributor>
      <comment>added [[Category:Computational fields of study]] using [[WP:HC|HotCat]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="261">{{Commons category|Computational geometry}}
{{Cat main|Computational geometry}}

==Related categories==

*[[:Category:Computational topology|Computational topology]]

[[Category:Computer science]]
[[Category:Geometry]]
[[Category:Computational fields of study]]</text>
      <sha1>890ubgkl08djvlywb6p1r822yz3ocpc</sha1>
    </revision>
  </page>
  <page>
    <title>Computer engineering</title>
    <ns>0</ns>
    <id>50408</id>
    <revision>
      <id>771984513</id>
      <parentid>771984330</parentid>
      <timestamp>2017-03-24T17:02:36Z</timestamp>
      <contributor>
        <username>Gilo1969</username>
        <id>8271180</id>
      </contributor>
      <comment>Reverted 2 pending edits by [[Special:Contributions/41.233.220.166|41.233.220.166]] to revision 770601065 by ClueBot NG</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="17679">{{pp-pc1}}
{{redirects here|Hardware engineering|engineering of other types of hardware|mechanical engineering|engineering electrical systems|electrical engineering}}
[[File:Motherboard.jpg|thumb|The [[motherboard]] used in a [[HD DVD]] player, the result of computer engineering efforts.]]

'''Computer engineering''' is a [[Discipline (academia)|discipline]] that integrates several fields of [[electrical engineering]] and [[computer science]] required to  develop [[computer hardware]] and [[computer software|software]].&lt;ref&gt;{{Cite book
 | last = IEEE Computer Society
 | authorlink = IEEE Computer Society

 |author2=ACM |authorlink2=Association for Computing Machinery 
 | title = Computer Engineering 2004: Curriculum Guidelines for Undergraduate Degree Programs in Computer Engineering
 | url = http://www.acm.org/education/education/curric_vols/CE-Final-Report.pdf
 | accessdate = December 17, 2012
 |date=December 12, 2004
 | page = iii
 | quote = Computer System engineering has traditionally been viewed as a combination of both electronic engineering (EE) and computer science (CS).
}}&lt;/ref&gt; Computer engineers usually have training in [[electronic engineering]] (or [[electrical engineering]]), [[software design]], and hardware-software integration instead of only [[software engineering]] or electronic engineering. Computer engineers are involved in many hardware and software aspects of computing, from the design of individual [[microcontroller]]s, [[microprocessor]]s, [[personal computer]]s, and [[supercomputer]]s, to [[circuit design]]. This field of engineering not only focuses on how computer systems themselves work, but also how they integrate into the larger picture.&lt;ref&gt;{{Cite web
 | last = Trinity College Dublin
 | url = http://www.tcd.ie/Engineering/about/what_is_eng/computer_eng_intro.html
 | title = What is Computer System Engineering
 | accessdate = April 21, 2006
}}, &quot;Computer engineers need not only to understand how computer systems themselves work, but also how they integrate into the larger picture. Consider the car. A modern car contains many separate computer systems for controlling such things as the engine timing, the brakes and the air bags. To be able to design and implement such a car, the computer engineer needs a broad theoretical understanding of all these various subsystems &amp; how they interact.&lt;/ref&gt;

Usual tasks involving computer engineers include writing software and [[firmware]] for [[embedded system|embedded]] [[microcontroller]]s, designing [[Very-large-scale integration|VLSI]] chips, designing [[analog device|analog]] [[sensor]]s, designing mixed signal [[circuit board]]s, and designing [[operating system]]s. Computer engineers are also suited for [[robotics]] research, which relies heavily on using digital systems to control and monitor electrical systems like [[Electric motor|motor]]s, [[Computer-mediated communication|communications]], and [[sensor]]s.

In many institutions, computer engineering students are allowed to choose areas of in-depth study in their junior and senior year, because the full breadth of knowledge used in the design and application of computers is beyond the scope of an undergraduate degree. Other institutions may require engineering students to complete one or two years of General Engineering before declaring computer engineering as their primary focus.&lt;ref&gt;{{cite web|title=Changing Majors @ Clemson| url=http://www.registrar.clemson.edu/html/changeMjr_Curr.htm |publisher=Clemson University |accessdate=September 20, 2011}}&lt;/ref&gt;&lt;ref&gt;{{cite web |title=Declaring a College of Engineering Major |url=http://freshmanengineering.uark.edu/2041.php |publisher=University of Arkansas |accessdate=September 20, 2011}}&lt;/ref&gt;&lt;ref&gt;{{cite web |title=Degree Requirements| url=http://www.cmu.edu/me/undergraduate/degree-requirements.html |publisher=Carnegie Mellon University |accessdate=September 20, 2011}}&lt;/ref&gt;&lt;ref&gt;{{cite web | url=http://www.uca.edu.ar/index.php/site/index/es/uca/facultad-de-ciencias-fisicomatematicas-e-ingenieria/alumnos/programas-de-materias/cc1y2/ | title=Programas de Materias |language=Spanish |publisher=Universidad Católica Argentina}}&lt;/ref&gt;

==History==
The first computer engineering degree program in the [[United States]] was established at [[Case Western Reserve University]] in 1972. {{As of|2015}}, there were 238 [[Accreditation Board for Engineering and Technology|ABET]]-accredited computer engineering programs in the US.&lt;ref&gt;{{Cite web|title = Find an ABET-Accredited Program {{!}} ABET|url = http://main.abet.org/aps/accreditedprogramsearch.aspx|website = main.abet.org|accessdate = 2015-11-29}}&lt;/ref&gt; In Europe, accreditation of computer engineering schools is done by a variety of agencies part of the [[EQANIE]] network. Due to increasing job requirements for engineers who can concurrently design hardware, [[Computer software|software]], firmware, and manage all forms of computer systems used in industry, some tertiary institutions around the world offer a [[bachelor's degree]] generally called computer engineering.  Both computer engineering and [[electronic engineering]] programs include analog and digital circuit design in their curriculum. As with most [[engineering]] disciplines, having a sound knowledge of [[mathematics]] and science is necessary for computer engineers.

==Work==
There are two major specialties in computer engineering: software and hardware.

===Computer software engineering===
{{Main article|Software engineering}}
Computer software engineers develop, design, and test software. They construct, and maintain computer programs, as well as set up networks such as &quot;[[intranets]]&quot; for companies.  Software engineers can also design or code new  applications to meet the needs of a business or individual. Some software engineers work independently as freelancers and sell their software products/applications to an enterprise or individual.&lt;ref name = &quot;C.S.E.&quot;&gt;{{cite web |title=Computer Software Engineer |url=http://www.bls.gov/k12/computers04.htm |publisher=Bureau of Labor Statistics |date=March 19, 2010 |accessdate=July 20, 2012 |archiveurl=https://web.archive.org/web/20130726002354/http://www.bls.gov/k12/computers04.htm |archivedate=July 26, 2013}}&lt;/ref&gt;

===Computer hardware engineering===
Most computer hardware engineers research, develop, design, and test various computer equipment. This can range from circuit boards and microprocessors to routers. Some update existing computer equipment to be more efficient and work with newer software. Most computer hardware engineers work in research laboratories and high-tech manufacturing firms. Some also work for the federal government. According to [[Bureau of Labor Statistics|BLS]], 95% of computer hardware engineers work in metropolitan areas.{{Citation needed|date=March 2015}} They generally work full-time. Approximately 33% of their work requires more than 40 hours a week. The median salary for employed qualified computer hardware engineers (2012) was $100,920 per year or $48.52 per hour. Computer hardware engineers held 83,300 jobs in 2012 in the USA.&lt;ref name = &quot;CHE&quot;&gt;{{cite web |title=Computer Hardware Engineers |url=http://www.bls.gov/ooh/architecture-and-engineering/computer-hardware-engineers.htm |date=January 8, 2014 |publisher=Bureau of Labor Statistics |accessdate=July 20, 2012}}&lt;/ref&gt;

==Specialty areas==
There are many specialty areas in the field of computer engineering.

===Coding, cryptography, and information protection===
{{Main article|Information security}}
Computer engineers work in coding, cryptography, and information protection to develop new methods for protecting various information, such as digital images and music, fragmentation, copyright infringement and other forms of tampering. Examples include work on wireless communications, multi-antenna systems, optical transmission, and [[digital watermarking]].&lt;ref name=&quot;SCCC&quot;&gt;{{cite web |title=Computer Engineering Overview |url=http://www.careercornerstone.org/pdf/compeng/compeng.pdf |publisher=Sloan Career Cornerstone Center |accessdate=July 20, 2012}}&lt;/ref&gt;

===Communications and wireless networks===
{{Main article|Communications networks|Wireless network}}
Those focusing on communications and wireless networks, work advancements in telecommunications systems and networks (especially wireless networks), modulation and error-control coding, and information theory. High-speed [[network planning and design|network design]], interference suppression and modulation, design and analysis of [[fault-tolerant system]], and storage and transmission schemes are all a part of this specialty.&lt;ref name = &quot;SCCC&quot;/&gt;

===Compilers and operating systems===
{{Main article|Compiler|Operating system}}
This specialty focuses on [[compilers]] and [[operating systems]] design and development. Engineers in this field develop new operating system architecture, program analysis techniques, and new techniques to assure quality. Examples of work in this field includes post-link-time code transformation algorithm development and new operating system development.&lt;ref name=&quot;SCCC&quot; /&gt;

===Computational science and engineering===
{{Main article|Computational science and engineering}}
Computational Science and Engineering is a relatively new discipline. According to the Sloan Career Cornerstone Center, individuals working in this area, &quot;computational methods are applied to formulate and solve complex mathematical problems in engineering and the physical and the social sciences. Examples include aircraft design, the plasma processing of nanometer features on semiconductor wafers, [[VLSI]] circuit design, radar detection systems, ion transport through biological channels, and much more&quot;.&lt;ref name=&quot;SCCC&quot; /&gt;

===Computer networks, mobile computing, and distributed systems===
{{Main article|Computer network| Mobile computing| Distributed computing}}
In this specialty, engineers build integrated environments for computing, communications, and information access. Examples include shared-channel wireless networks, [[Adaptive Management|adaptive resource management]] in various systems, and improving the quality of service in mobile and ATM environments. Some other examples include work on wireless network systems and fast Ethernet cluster wired systems.&lt;ref name=&quot;SCCC&quot; /&gt;

===Computer systems: architecture, parallel processing, and dependability===
{{Main article|Computer architecture|Parallel computing|Dependability}}
Engineers working in computer systems work on research projects that allow for reliable, secure, and high-performance computer systems. Projects such as designing processors for multi-threading and parallel processing are included in this field. Other examples of work in this field include development of new theories, algorithms, and other tools that add performance to computer systems.&lt;ref name=&quot;SCCC&quot; /&gt;

===Computer vision and robotics===
{{Main article|Computer vision|Robotics}}
In this specialty, computer engineers focus on developing [[Visual sensor network|visual sensing technology]] to sense an environment, representation of an environment, and manipulation of the environment. The gathered three-dimensional information is then implemented to perform a variety of tasks. These include, improved human modeling, image communication, and human-computer interfaces, as well as devices such as special-purpose cameras with versatile vision sensors.&lt;ref name=&quot;SCCC&quot; /&gt;

===Embedded systems===
[[File:Oxygen devices.svg|thumb|right|Examples of devices that use embedded systems.]]
{{Main article|Embedded systems}}
Individuals working in this area design technology for enhancing the speed, reliability, and performance of systems. Embedded systems are found in many devices from a small FM radio to the space shuttle. According to the Sloan Cornerstone Career Center, ongoing developments in embedded systems include &quot;automated vehicles and equipment to conduct search and rescue, automated transportation systems, and human-robot coordination to repair equipment in space.&quot;&lt;ref name=&quot;SCCC&quot; /&gt;

===Integrated circuits, VLSI design, testing and CAD===
{{Main article|Integrated circuit|Very-large-scale integration}}
This specialty of computer engineering requires adequate knowledge of electronics and electrical systems. Engineers working in this area work on enhancing the speed, reliability, and energy efficiency of next-generation very-large-scale integrated ([[VLSI]]) circuits and microsystems. An example of this specialty is work done on reducing the power consumption of VLSI algorithms and architecture.&lt;ref name=&quot;SCCC&quot; /&gt;

===Signal, image and speech processing===
{{Main article| Signal processing| Image processing| Speech processing}}
Computer engineers in this area develop improvements in human–computer interaction, including speech recognition and synthesis, medical and scientific imaging, or communications systems. Other work in this area includes computer vision development such as recognition of human facial features.&lt;ref name=&quot;SCCC&quot; /&gt;

==Education==
Most entry-level computer engineering jobs require at least a bachelor's degree in computer engineering. Sometimes a degree in [[electronic engineering]] is accepted, due to the similarity of the two fields. Because hardware engineers commonly work with computer software systems, a background in computer programming usually is needed. According to BLS, &quot;a computer engineering major is similar to electrical engineering but with some computer science courses added to the curriculum&quot;.&lt;ref name = &quot;CHE&quot; /&gt; Some large firms or specialized jobs require a master's degree.

It is also important for computer engineers to keep up with rapid advances in technology. Therefore, many continue learning throughout their careers. This can be helpful, especially when it comes to learning new skills or improving existing ones. For example, as the relative cost of fixing a bug increases the further along it is in the software development cycle, there can be greater cost savings attributed to developing and testing for quality code as soon as possible in the process, and particularly before release.&lt;ref name=&quot;The cost of fixing a bug&quot;&gt;{{cite web|url=http://www.feabhas.com/sites/default/files/uploads/News/Feabhas_Infographic_FINAL.pdf|title=Feabhas_Infographic_FINAL|format=pdf|website=feabhas|publisher=Feabhas}}&lt;/ref&gt;

==Job outlook in the United States==

===Computer software engineering===
According to the U.S. [[Bureau of Labor Statistics]] (BLS), &quot;computer applications software engineers and computer systems software engineers are projected to be among the faster than average growing occupations&quot; from 2014–24, with a projected growth rate of 17%.&lt;ref name=&quot;softdev&quot;&gt;{{cite web|url=http://www.bls.gov/ooh/computer-and-information-technology/software-developers.htm|title=Software Developers: Occupational Outlook Handbook|publisher=U.S. Bureau of Labor Statistics}}&lt;/ref&gt; This is down from the 2012 to 2022 BLS estimate of 22% for software developers.&lt;ref name=&quot;C.S.E.&quot; /&gt;&lt;ref name=&quot;softdev&quot; /&gt; And, further down from the 30% 2010 to 2020 BLS estimate.&lt;ref name = &quot;CSE2&quot;&gt;{{cite web |title=Software Developers |url=http://www.bls.gov/ooh/computer-and-information-technology/software-developers.htm |date=January 8, 2014 |publisher=Bureau of Labor Statistics |accessdate=July 21, 2012}}&lt;/ref&gt; In addition, growing concerns over cyber security add up to put computer software engineering high above the average rate of increase for all fields. However, some of the work will be outsourced in foreign countries. Due to this, job growth will not be as fast as during the last decade, as jobs that would have gone to computer software engineers in the United States would instead go to computer software engineers in countries such as India.&lt;ref name=&quot;bls.gov&quot;&gt;{{cite web|url=http://www.bls.gov/ooh/computer-and-information-technology/computer-programmers.htm|title=Computer Programmers: Occupational Outlook Handbook|publisher=U.S. Bureau of Labor Statistics|}}&lt;/ref&gt; In addition the BLS Job Outlook for Computer Programmers, 2014-24 has an -8% (a decline in their words)&lt;ref name=&quot;bls.gov&quot;/&gt; for those who program computers (i.e. embedded systems) who are not computer application developers.

===Computer hardware engineering===
According to the [[Bureau of Labor Statistics|BLS]], Job Outlook employment for computer hardware engineers, 2014-24 is 3% (&quot;Slower than average&quot; in their own words when compared to other occupations)&quot;&lt;ref name=&quot;hweng&quot;&gt;{{cite web|url=http://www.bls.gov/ooh/architecture-and-engineering/computer-hardware-engineers.htm|title=Computer Hardware Engineers: Occupational Outlook Handbook|publisher=U.S. Bureau of Labor Statistics}}&lt;/ref&gt; and is down from 7% for 2012 to 2022 BLS estimate&lt;ref name=&quot;hweng&quot; /&gt; and is further down from 9% in the BLS 2010 to 2020 estimate.&quot; Today, computer hardware is somehow equal to Electronic and Computer Engineering (ECE) and has divided to many subcategories, the most significant of them is Embedded system design.&lt;ref name = &quot;CHE&quot; /&gt;

==Similar occupations and fields==
* [[Computer programming]]
* [[Electrical engineering]]
* [[Software development]]
* [[Systems analyst]]

==See also==
* [[List of universities with computer engineering programs]]

==References==
{{Reflist|30em}}

{{Engineering fields}}
{{Technology-footer}}

{{Academic degrees}}

{{Authority control}}

{{DEFAULTSORT:Computer Engineering}}
[[Category:Computer engineering| ]]
[[Category:Electrical engineering]]
[[Category:Electronic engineering]]
[[Category:Computer science]]
[[Category:Engineering disciplines]]

[[es:Ingeniería en computación]]
[[zh:计算机工程]]</text>
      <sha1>kdus3s7z5ihqhkk97npu9ztrw9e1jmk</sha1>
    </revision>
  </page>
  <page>
    <title>Category:Software</title>
    <ns>14</ns>
    <id>691633</id>
    <revision>
      <id>744003487</id>
      <parentid>734236388</parentid>
      <timestamp>2016-10-12T14:34:06Z</timestamp>
      <contributor>
        <username>Danny Delamo</username>
        <id>29160149</id>
      </contributor>
      <minor/>
      <comment>Software</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1001">{{catdiffuse}}
{{JEL code|C88}}
{{Commons category|Software}}
{{Infobox catalog
|DDC = 
|LCC =
|UDC = 0 004.4
}}

This [[Wikipedia:Category|category]] is about all aspects of '''[[software]]''' (SW) which here is taken to include the following categories:
*[[:category:application software|Application software]] ([[application software]]: office suites, word processors, spreadsheets, etc.)
*[[:category:system software|System software]] ([[system software]]: operating systems, device drivers, desktop environments, etc.)
*[[:category:computer programming tools|Computer programming tools]] ([[programming tools]]: assemblers, compilers, linkers, etc.)

The first two of these are classified for running software on computers (i.e., actually ''using'' the computers), while the last one is about developing the software in the first place.

{{cat main|Software}}

[[Category:Computer science]]
[[Category:Computing]]
[[Category:Digital media]]
[[Category:Intellectual works]]
[[Category:Mass media]]</text>
      <sha1>9kwdr8qma8uofsg24cjxqelxs3sxo1v</sha1>
    </revision>
  </page>
  <page>
    <title>Software</title>
    <ns>0</ns>
    <id>5309</id>
    <revision>
      <id>772034427</id>
      <parentid>772033863</parentid>
      <timestamp>2017-03-24T23:01:08Z</timestamp>
      <contributor>
        <username>Murray Langton</username>
        <id>25895</id>
      </contributor>
      <comment>/* top */ restore unexplained deletion of content.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25901">{{other uses}}
[[File:Operating system placement (software).svg|thumb|upright|A diagram showing how the [[User (computing)|user]] interacts with [[application software]] on a typical [[desktop computer]].The application software layer interfaces with the [[operating system]], which in turn communicates with the [[Personal computer hardware|hardware]]. The arrows indicate information]]

'''Computer software''', or simply '''software''', is that part of a [[computer system]] that consists of [[data (computing)|data]] or computer instructions, in contrast to the [[Computer hardware|physical hardware]] from which the system is built. In [[computer science]] and [[software engineering]], computer software is all [[information]] processed by [[computer system]]s, [[Computer program|program]]s and data. Computer software includes [[computer program]]s, [[Library (computing)|libraries]] and related non-executable [[Data (computing)|data]], such as [[Software documentation|online documentation]] or [[digital media]]. Computer hardware and software require each other and neither can be realistically used on its own.

At the lowest level, [[executable code]] consists of [[Machine code|machine language instructions]] specific to an individual [[Microprocessor|processor]]—typically a [[central processing unit]] (CPU). A machine language consists of groups of [[Binary numbers|binary values]] signifying processor instructions that change the state of the computer from its preceding state. For example, an instruction may change the value stored in a particular storage location in the computer—an effect that is not directly observable to the user. An instruction may also (indirectly) cause something to appear on a display of the computer system—a state change which should be visible to the user. The processor carries out the instructions in the order they are provided, unless it is instructed to [[branch instruction|&quot;jump&quot; to a different instruction]], or is interrupted.

The majority of software is written in [[high-level programming language]]s that are easier and more efficient for programmers, meaning closer to a [[natural language]].&lt;ref&gt;{{cite web|title=Compiler construction|url=http://www.cs.uu.nl/education/vak.php?vak=INFOMCCO}}&lt;/ref&gt; High-level languages are translated into machine language using a [[compiler]] or an [[Interpreter (computing)|interpreter]] or a combination of the two. Software may also be written in a low-level [[assembly language]], essentially, a vaguely [[mnemonic]] representation of a machine language using a natural language alphabet, which is translated into machine language using an [[Assembly language|assembler]].

==History==
{{main article|History of software}}
An outline ([[algorithm]]) for what would have been the first piece of software was written by [[Ada Lovelace]] in the 19th century, for the planned [[Analytical Engine]]. However, neither the Analytical Engine nor any software for it were ever created.

The first theory about software—prior to creation of computers as we know them today—was proposed by Alan Turing in his 1935 essay ''Computable numbers with an application to the Entscheidungsproblem'' (decision problem).

This eventually led to the creation of the twin academic fields of computer science and software engineering, which both study software and its creation. Computer science is more theoretical (Turing's essay is an example of computer science), whereas software engineering focuses on more practical concerns.

However, prior to 1946, software as we now understand it—programs stored in the memory of stored-program digital computers—did not yet exist. The first electronic computing devices were instead rewired in order to &quot;reprogram&quot; them.

==Types of software==
{{see also|List of software categories}}

On virtually all computer platforms, software can be grouped into a few broad categories.

===Purpose, or domain of use===

Based on the goal, computer software can be divided into:
* ''[[Application software]]'', which is software that uses the computer system to perform special functions or provide [[video game|entertainment functions]] beyond the basic operation of the computer itself. There are many different types of application software, because the range of tasks that can be performed with a modern computer is so large—see [[list of software]].
* ''[[System software]]'', which is software that directly operates the [[computer hardware]], to provide basic functionality needed by users and other software, and to provide a platform for running application software.&lt;ref&gt;{{cite web|title=System Software|url=http://home.olemiss.edu/~misbook/sfsysfm.htm|archive-url=https://web.archive.org/web/20010530092843/http://home.olemiss.edu:80/~misbook/sfsysfm.htm|dead-url=yes|archive-date=2001-05-30|publisher=The University of Mississippi}}&lt;/ref&gt; System software includes:
** ''[[Operating system]]s'', which are essential collections of software that manage resources and provides common services for other software that runs &quot;on top&quot; of them. [[Supervisory program]]s, [[boot loader]]s, [[shell (computing)|shells]] and [[window system]]s are core parts of operating systems. In practice, an operating system comes bundled with additional software (including application software) so that a user can potentially do some work with a computer that only has an operating system.
** ''[[Device driver]]s'', which operate or control a particular type of device that is attached to a computer. Each device needs at least one corresponding device driver; because a computer typically has at minimum at least one input device and at least one output device, a computer typically needs more than one device driver.
** ''[[Software utility|Utilities]]'', which are computer programs designed to assist users in the maintenance and care of their computers.
* ''[[Malicious software]]'' or ''malware'', which is software that is developed to harm and disrupt computers. As such, malware is undesirable. Malware is closely associated with computer-related crimes, though some malicious programs may have been designed as [[practical joke]]s.

===Nature or domain of execution===
* [[Desktop applications]] such as [[web browser]]s and [[Microsoft Office]], as well as [[smartphone]] and [[Tablet computer|tablet]] applications (called &quot;[[mobile app|apps]]&quot;). (There is a push in some parts of the software industry to merge desktop applications with mobile apps, to some extent. [[Windows 8]], and later [[Ubuntu Touch]], tried to allow the same style of application user interface to be used on desktops, laptops and mobiles.)
* [[JavaScript]] scripts are pieces of software traditionally embedded in [[web pages]] that are run directly inside the [[web browser]] when a web page is loaded without the need for a web browser plugin. Software written in other programming languages can also be run within the web browser if the software is either translated into JavaScript, or if a web browser plugin that supports that language is installed; the most common example of the latter is [[ActionScript]] scripts, which are supported by the [[Adobe Flash]] plugin.
* [[Server software]], including:
** [[Web application]]s, which usually run on the [[web server]] and output dynamically generated web pages to web browsers, using e.g. [[PHP]], [[Java (programming language)|Java]], [[ASP.NET]], or even [[Node.js|JavaScript that runs on the server]]. In modern times these commonly include some JavaScript to be run in the web browser as well, in which case they typically run partly on the server, partly in the web browser.
* [[Plug-in (computing)|Plugins]] and extensions are software that extends or modifies the functionality of another piece of software, and require that software be used in order to function;
* [[Embedded software]] resides as firmware within [[embedded system]]s, devices dedicated to a single use or a few uses such as [[car]]s and [[television]]s (although some embedded devices such as wireless chipsets can ''themselves'' be part of an ordinary, non-embedded computer system such as a PC or [[smartphone]]).&lt;ref&gt;{{cite web|title=Embedded Software—Technologies and Trends|url=http://www.computer.org/csdl/mags/so/2009/03/mso2009030014.html|publisher=IEEE Computer Society|date=May–June 2009|accessdate=6 November 2013}}&lt;/ref&gt; In the embedded system context there is sometimes no clear distinction between the system software and the application software. However, some embedded systems run [[embedded operating system]]s, and these systems do retain the distinction between system software and application software (although typically there will only be one, fixed, application which is always run).
* [[Microcode]] is a special, relatively obscure type of embedded software which tells the processor ''itself'' how to execute machine code, so it is actually a lower level than machine code. It is typically proprietary to the processor manufacturer, and any necessary correctional microcode software updates are supplied by them to users (which is much cheaper than shipping replacement processor hardware). Thus an ordinary programmer would not expect to ever have to deal with it.

===Programming tools===
{{main article|Programming tool}}
Programming tools are also software in the form of programs or applications that [[software developer]]s (also known as ''programmers, coders, hackers'' or ''software engineers'') use to create, [[Debugging|debug]], [[Software maintenance|maintain]] (i.e. improve or fix), or otherwise [[Technical support|support]] software. Software is written in one or more programming languages; there are many programming languages in existence, and each has at least one implementation, each of which consists of its own set of programming tools. These tools may be relatively self-contained programs such as [[compiler]]s, [[debugger]]s, [[interpreter (computing)|interpreters]], [[linker (computing)|linkers]], and [[text editor]]s, that can be combined together to accomplish a task; or they may form an [[integrated development environment]] (IDE), which combines much or all of the functionality of such self-contained tools. IDEs may do this by either invoking the relevant individual tools or by re-implementing their functionality in a new way. An IDE can make it easier to do specific tasks, such as searching in files in a particular project. Many programming language implementations provide the option of using both individual tools or an IDE.

==Software topics==

===Architecture===
{{see also|Software architecture}}
Users often see things differently from programmers. People who use modern general purpose computers (as opposed to [[embedded system]]s, [[analog computer]]s and [[supercomputer]]s) usually see three layers of software performing a variety of tasks: platform, application, and user software.
* Platform software: The [[Platform (computing)|Platform]] includes the [[firmware]], [[device driver]]s, an [[operating system]], and typically a [[graphical user interface]] which, in total, allow a user to interact with the computer and its [[peripheral]]s (associated equipment). Platform software often comes bundled with the computer. On a [[Personal computer|PC]] one will usually have the ability to change the platform software.
* Application software: [[Application software]] or Applications are what most people think of when they think of software. Typical examples include office suites and video games. [[Application software]] is often purchased separately from computer hardware. Sometimes applications are bundled with the computer, but that does not change the fact that they run as independent applications. Applications are usually independent programs from the operating system, though they are often tailored for specific platforms. Most users think of compilers, databases, and other &quot;system software&quot; as applications.
* User-written software: [[End-user development]] tailors systems to meet users' specific needs. User software include spreadsheet templates and [[word processor]] templates. Even email filters are a kind of user software. Users create this software themselves and often overlook how important it is. Depending on how competently the user-written software has been integrated into default application packages, many users may not be aware of the distinction between the original packages, and what has been added by co-workers.

===Execution===
{{main article|Execution (computing)}}
Computer software has to be &quot;loaded&quot; into the [[computer storage|computer's storage]] (such as the [[hard drive]] or [[Computer memory|memory]]). Once the software has loaded, the computer is able to ''execute'' the software. This involves passing [[instruction (computer science)|instructions]] from the [[application software]], through the system software, to the hardware which ultimately receives the instruction as [[machine language|machine code]]. Each instruction causes the computer to carry out an operation—moving [[data (computing)|data]], carrying out a [[computation]], or altering the [[control flow]] of instructions.

Data movement is typically from one place in memory to another. Sometimes it involves moving data between memory and registers which enable high-speed data access in the CPU. Moving data, especially large amounts of it, can be costly. So, this is sometimes avoided by using &quot;pointers&quot; to data instead. Computations include simple operations such as incrementing the value of a variable data element. More complex computations may involve many operations and data elements together.

&lt;!-- This section is simply to long for this article and needs to be compressed into the intro above, or moved to the article itself.

Instructions may be performed sequentially, conditionally, or iteratively. Sequential instructions are those operations that are performed one after another. Conditional instructions are performed such that different sets of instructions execute depending on the value(s) of some data. In some languages this is known as an &quot;if&quot; statement. Iterative instructions are performed repetitively and may depend on some data value. This is sometimes called a &quot;loop.&quot; Often, one instruction may &quot;call&quot; another set of instructions that are defined in some other program or [[module (programming)|module]]. When more than one computer processor is used, instructions may be executed simultaneously.

A simple example of the way software operates is what happens when a user selects an entry such as &quot;Copy&quot; from a menu. In this case, a conditional instruction is executed to copy text from data in a 'document' area residing in memory, perhaps to an intermediate storage area known as a 'clipboard' data area. If a different menu entry such as &quot;Paste&quot; is chosen, the software may execute the instructions to copy the text from the clipboard data area to a specific location in the same or another document in memory.

Depending on the application, even the example above could become complicated. The field of software engineering endeavors to manage the complexity of how software operates. This is especially true for software that operates in the context of a large or powerful [[computer system]].

Currently, almost the only limitations on the use of computer software in applications is the ingenuity of the designer/programmer. Consequently, large areas of activities (such as playing grand master level chess) formerly assumed to be incapable of software simulation are now routinely programmed. The only area that has so far proved reasonably secure from software simulation is the realm of human art— especially, pleasing music and literature.{{Citation needed|date=June 2007}}

Kinds of software by operation: [[computer program]] as [[executable]], [[source code]] or [[script (computer programming)|script]], [[computer configuration|configuration]].--&gt;

===Quality and reliability===
{{main article|Software quality|Software testing|Software reliability}}
Software quality is very important, especially for [[commercial software|commercial]] and system software like [[Microsoft Office]], [[Microsoft Windows]] and [[Linux]]. If software is faulty (buggy), it can delete a person's work, crash the computer and do other unexpected things. Faults and errors are called &quot;[[Software bug|bugs]]&quot; which are often discovered during alpha and beta testing. Software is often also a victim to what is known as [[software aging]], the progressive performance degradation resulting from a combination of unseen bugs.

Many bugs are discovered and eliminated (debugged) through [[software testing]]. However, software testing rarely—if ever—eliminates every bug; some programmers say that &quot;every program has at least one more bug&quot; (Lubarsky's Law).&lt;ref name=&quot;github&quot;&gt;{{cite web| url=https://github.com/mark-watson/scripting-intelligence-book-examples/blob/master/part1/wikipedia_text/software.txt | title=scripting intelligence book examples }}&lt;/ref&gt; In the [[Waterfall model|waterfall]] method of software development, separate testing teams are typically employed, but in newer approaches, collectively termed [[agile software development]], developers often do all their own testing, and demonstrate the software to users/clients regularly to obtain feedback. Software can be tested through [[unit testing]], [[regression testing]] and other methods, which are done manually, or most commonly, automatically, since the amount of code to be tested can be quite large. For instance, [[NASA]] has extremely rigorous software testing procedures for many operating systems and communication functions. Many NASA-based operations interact and identify each other through command programs. This enables many people who work at NASA to check and evaluate functional systems overall. Programs containing command software enable hardware engineering and system operations to function much easier together.

===License===
{{main article|Software license}}
The software's license gives the user the right to use the software in the licensed environment, and in the case of [[free software license]]s, also grants other rights such as the right to make copies.

[[Proprietary software]] can be divided into two types:

* [[freeware]], which includes the category of &quot;free trial&quot; software or &quot;[[freemium]]&quot; software (in the past, the term [[shareware]] was often used for free trial/freemium software). As the name suggests, freeware can be used for free, although in the case of free trials or freemium software, this is sometimes only true for a limited period of time or with limited functionality.
* software available for a fee, often inaccurately termed &quot;[[commercial software]]&quot;, which can only be legally used on purchase of a license.

[[Open source software]], on the other hand, comes with a [[free software license]], granting the recipient the rights to modify and redistribute the software.

===Patents===
{{main article|Software patent|Software patent debate}}
Software patents, like other types of patents, are theoretically supposed to give an inventor an exclusive, time-limited license for a ''detailed idea (e.g. an algorithm) on how to implement'' a piece of software, or a component of a piece of software. Ideas for useful things that software could ''do'', and user ''requirements'', are not supposed to be patentable, and concrete implementations (i.e. the actual software packages implementing the patent) are not supposed to be patentable either—the latter are already covered by copyright, generally automatically. So software patents are supposed to cover the middle area, between requirements and concrete implementation. In some countries, a requirement for the claimed invention to have an effect on the physical world may also be part of the requirements for a software patent to be held valid—although since ''all'' useful software has effects on the physical world, this requirement may be open to debate.

Software patents are controversial in the software industry with many people holding different views about them. One of the sources of controversy is that the aforementioned split between initial ideas and patent does not seem to be honored in practice by patent lawyers—for example the patent for [[Aspect-Oriented Programming]] (AOP), which purported to claim rights over ''any'' programming tool implementing the idea of AOP, howsoever implemented. Another source of controversy is the effect on innovation, with many distinguished experts and companies arguing that software is such a fast-moving field that software patents merely create vast additional litigation costs and risks, and actually retard innovation. In the case of debates about software patents outside the United States, the argument has been made that large American corporations and patent lawyers are likely to be the primary beneficiaries of allowing or continue to allow software patents.

==Design and implementation==
{{main article|Software development|Computer programming|Software engineering}}
Design and implementation of software varies depending on the complexity of the software. For instance, the design and creation of [[Microsoft Word]] took much more time than designing and developing [[Microsoft Notepad]] because the latter has much more basic functionality.

Software is usually designed and created (aka coded/written/programmed) in [[integrated development environment]]s (IDE) like [[Eclipse (software)|Eclipse]], [[IntelliJ IDEA|IntelliJ]] and [[Microsoft Visual Studio]] that can simplify the process and [[compiler|compile]] the software (if applicable). As noted in a different section, software is usually created on top of existing software and the [[application programming interface]] (API) that the underlying software provides like [[GTK+]], JavaBeans or [[Swing (Java)|Swing]]. Libraries (APIs) can be categorized by their purpose. For instance, the [[Spring framework|Spring Framework]] is used for implementing [[enterprise application]]s, the [[Windows Forms]] library is used for designing graphical user interface (GUI) applications like [[Microsoft Word]], and [[Windows Communication Foundation]] is used for designing [[web service]]s. When a program is designed, it relies upon the API. For instance, if a user is designing a Microsoft Windows desktop application, he or she might use the [[.NET Framework|.NET]] Windows Forms library to design the desktop application and call its APIs like ''Form1.Close()'' and ''Form1.Show()''&lt;ref&gt;{{cite web |url=http://msdn.microsoft.com/en-us/library/default.aspx | title=MSDN Library|accessdate=2010-06-14}}&lt;/ref&gt; to close or open the application, and write the additional operations him/herself that it needs to have. Without these APIs, the programmer needs to write these APIs him/herself. Companies like [[Oracle Corporation|Oracle]] and [[Microsoft]] provide their own APIs so that many applications are written using their [[Library (computing)|software libraries]] that usually have numerous APIs in them.

[[Data structure]]s such as [[hash table]]s, [[array data type|arrays]], and [[binary tree]]s, and [[algorithm]]s such as [[quicksort]], can be useful for creating software.

Computer software has special economic characteristics that make its design, creation, and distribution different from most other economic goods.{{Specify|Which characteristics?|date=May 2012}}&lt;ref&gt;{{cite journal|author=v. Engelhardt, Sebastian |year=2008|url=https://ideas.repec.org/p/jrp/jrpwrp/2008-045.html |title=The Economic Properties of Software|journal= Jena Economic Research Papers| volume= 2| issue= 2008–045.}}&lt;/ref&gt;&lt;ref&gt;{{cite web|url=http://dankaminsky.com/1999/03/02/69/ |title=Why Open Source Is The Optimum Economic Paradigm for Software|first= Dan |last=Kaminsky |year=1999}}&lt;/ref&gt;

A person who creates software is called a [[programmer]], [[software engineer]] or [[software developer]], terms that all have a similar meaning. More informal terms for programmer also exist such as &quot;coder&quot; and &quot;[[Hacker (expert)|'''hacker''']]&quot;{{Spaced ndash}}although use of the latter word may cause confusion, because it is more often used to mean [[Hacker (computer security)|someone who illegally breaks into computer systems]].

==Industry and organizations==
{{main article|Software industry}}
A great variety of software companies and programmers in the world comprise a software industry. Software can be quite a profitable industry: [[Bill Gates]], the co-founder of [[Microsoft]] was the richest person in the world in 2009, largely due to his ownership of a significant number of shares in Microsoft, the company responsible for [[Microsoft Windows]] and [[Microsoft Office]] software products.

Non-profit software organizations include the [[Free Software Foundation]], [[GNU Project]] and [[Mozilla Foundation]]. Software standard organizations like the [[W3C]], [[IETF]] develop recommended software standards such as [[XML]], [[HTTP]] and [[HTML]], so that software can interoperate through these standards.

Other well-known large software companies include [[Oracle Corporation|Oracle]], [[Novell]], [[SAP AG|SAP]], [[Symantec]], [[Adobe Systems]], and [[Corel]], while small companies often provide innovation.

==See also==
* [[Software release life cycle]]
* [[Independent software vendor]]
* [[List of software]]
* [[Software asset management]]
{{portal bar|Software|Free software|Information technology}}

==References==
{{reflist}}

==External links==
{{Sister project links | wikt=software | commons=Special:Search/Software | b= | n= | s= | v=Computer Software | voy= |q=no}}
* {{dmoz|Computers/Software}}&lt;!--ref name=&quot;github&quot;/--&gt;

{{Software digital distribution platforms|state=collapsed}}
{{Authority control}}

[[Category:Computing]]
[[Category:Computer science]]
[[Category:Software| ]]</text>
      <sha1>oxna02lby3q0j6p9ld53kxv28jjqzm0</sha1>
    </revision>
  </page>
  <page>
    <title>Quaject</title>
    <ns>0</ns>
    <id>51401190</id>
    <revision>
      <id>769703068</id>
      <parentid>760315192</parentid>
      <timestamp>2017-03-11T04:12:12Z</timestamp>
      <contributor>
        <username>Bender the Bot</username>
        <id>28903366</id>
      </contributor>
      <minor/>
      <comment>/* top */HTTP&amp;rarr;HTTPS, per [[Wikipedia:Bots/Requests for approval/Bender the Bot 8|BRFA 8]] using [[Project:AWB|AWB]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2769">In [[computer science]], a '''Quaject''' is an [[Object (computer programming)|object]]-like [[data structure]] containing both data and code (or pointers to code), exposed as an interface in the form of ''[[Method (computer programming)|callentries]]'', and can accept a list of callentries to other quajects for ''[[Callback (computer programming)|callbacks]]'' and ''[[Continuation|callouts]]''. They were developed by [[Alexia Massalin]] in 1989 for the ''[[Self-modifying code#Massalin's Synthesis kernel|Synthesis kernel]]'',&lt;ref&gt;{{cite thesis |type=Ph.D. |last=Massalin |first=Henry |date=1992 |title=Synthesis: An Efficient Implementation of Fundamental Operating System Services |publisher=Columbia University| access-date=23 Aug 2016 |url=http://citeseer.ist.psu.edu/viewdoc/versions?doi=10.1.1.29.4871}}&lt;/ref&gt; and named for the ''Qua! Machine'', a unique hardware platform built by Massalin. The origin of the term 'qua' is unclear; Massalin claims humorously that it is a sound made by [[koala]]s.&lt;ref&gt;{{cite magazine |last=Poole |first=Gary A. |date=1 Dec 1996 |title=Qua |url=https://www.wired.com/1996/12/ffmassalin/ |magazine=Wired |publisher=Condé Nast |access-date=23 Aug 2016}}&lt;/ref&gt;

The main purpose of quajects is to provide an [[Abstraction (software engineering)|abstraction]] to manage [[self-modifying code]], by allowing runtime code optimizing on a per-object basis. While the original Synthesis kernel required quajects to be written in hand-developed [[assembly language]], this was done to avoid developing a complex compiler; Massalin noted that [[just-in-time compilation]] (JIT) for a [[high-level programming language]] that permits runtime [[Automatic programming|code generation]], as in [[Lisp (programming language)|Lisp]] or [[Smalltalk]], can also apply this approach, though she also asserted that the complexity of such a compiler was likely to be prohibitive.

Quajects differ from more conventional objects in two key ways: first, they always use a form of the [[dependency injection]] pattern to manage both interfaces to other quajects, and continuations out of the quaject; the list of callentry references for this is part of quaject creation, and may be updated during the quaject's lifetime. Second, and more critically, a given quaject's set of methods can be unique to the specific quaject; methods for a type or class of quajects are stored as one or more templates, rather than as fixed code. While shared methods can be accessed through a common table of pointers, individual quajects can also have methods that are generated specifically to tailor the performance for that quaject's behavior.

==References==
{{Reflist}}

[[Category:Computer science]]
[[Category:Operating system technology]]

{{comp-sci-stub}}</text>
      <sha1>pcog8bllxn5eosx83s18uvrg260wo61</sha1>
    </revision>
  </page>
  <page>
    <title>Business software</title>
    <ns>0</ns>
    <id>1037763</id>
    <revision>
      <id>771457463</id>
      <parentid>770063169</parentid>
      <timestamp>2017-03-21T17:18:00Z</timestamp>
      <contributor>
        <username>Swoophle</username>
        <id>30095676</id>
      </contributor>
      <minor/>
      <comment>distinguish commercial software, proprietary software</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14469">{{merge|Enterprise software|date=October 2015}}

{{About | software made for business | the business of selling software | Software business}}

{{distinguish|Proprietary software|Commercial software}}

'''Business software''' or a business application is any [[software]] or set of computer programs used by business users to perform various business functions. These business applications are used to increase productivity, to measure productivity and to perform other business functions accurately.

By and large, business software is likely to be developed to meet the needs of a specific business, and therefore is not easily transferable to a different business  environment, unless its nature and operation is identical. Due to the unique requirements of each business, off-the-shelf software is unlikely to completely address a company's needs. However, where an on-the-shelf solution is necessary, due to time or monetary considerations, some level of customization is likely to be required. Exceptions do exist, depending on the business in question, and thorough research is always required before committing to bespoke or off-the-shelf solutions.

Some business applications are interactive, i.e., they have a [[graphical user interface]] or user interface and users can query/modify/input data and view results instantaneously. They can also run reports instantaneously. Some business applications run in batch mode: they are set up to run based on a predetermined event/time and a business user does not need to initiate them or monitor them.

Some business applications are built in-house and some are bought from vendors (off the shelf software products). These business applications are installed on either desktops or big servers. Prior to the introduction of COBOL (a universal compiler) in 1965, businesses developed their own unique machine language.  RCA's language consisted of a 12-position instruction. For example, to read a record into memory, the first two digits would be the instruction (action) code. The next four positions of the instruction (an 'A' address) would be the exact leftmost memory location where you want the readable character to be placed. Four positions (a 'B' address) of the instruction would note the very rightmost memory location where you want the last character of the record to be located. A two digit 'B' address also allows a modification of any instruction. Instruction codes and memory designations excluded the use of 8's or 9's. The first RCA business application was implemented in 1962 on a 4k RCA 301.  The RCA 301, mid frame 501, and large frame 601 began their marketing in early 1960.             

Many kinds of users are found within the business environment, and can be categorized by using a small, medium and large matrix:

* The small business market generally consists of home [[accounting software]], and [[office suite]]s such as [[OpenOffice.org]] or [[Microsoft Office]].
* The medium size, or [[small and medium-sized enterprise]] (SME), has a broader range of software applications, ranging from accounting, [[groupware]], [[customer relationship management]], [[human resource management systems]], [[outsourcing relationship management]], loan origination software, [[shopping cart software]], field service software, and other productivity enhancing applications.
* The last segment covers enterprise level software applications, such as those in the fields of [[enterprise resource planning]], [[enterprise content management]] (ECM), [[business process management]] (BPM) and [[product lifecycle management]]. These applications are extensive in scope, and often come with modules that either add native functions, or incorporate the functionality of third-party computer programs.

Technologies that previously only existed in [[peer-to-peer]] software applications, like [[Kazaa]] and [[Napster]], are starting to appear within business applications.

== Types of business tools ==
* [[Enterprise application software]] (EAS)
* [[Resource Management]]
* [[Dashboard (business)|Digital dashboards]], also known as [[business intelligence]] dashboards, enterprise dashboards, or executive dashboards.  These are visually based summaries of business data that show at-a-glance understanding of conditions through metrics and key performance indicators (KPIs). Dashboards are a very popular  tools that have arisen in the last few years.{{when|date=April 2012}}
* Online analytical processing ([[OLAP]]),  (which include [[HOLAP]], [[ROLAP]] and [[MOLAP]]) - are a capability of some management, decision support, and executive information systems that support interactive examination of large amounts of data from many perspectives.&lt;ref&gt;James O'Brien and George Marakas, Management Information Systems, 7th ed. McGraw-Hill&lt;/ref&gt;
* [[List of reporting software|Reporting software]] generates aggregated views of data to keep the management informed about the state of their business.
* [[Procurement software]] is business software that helps to automate the purchasing function of organizations.
* [[Data mining]] is the extraction of consumer information from a database by utilizing software that can isolate and identify previously unknown patterns or trends in large amounts of data. There is a variety of data mining techniques that reveal different types of patterns.&lt;ref&gt;Dictionary of Marketing Terms, 3rd Edition&lt;/ref&gt; Some of the techniques that belong here are [[Statistics|statistical methods]] (particularly [[business statistics]]) and [[neural network]]s, as very advanced means of analyzing data.
* [[Business performance management]] (BPM)
* [[Document management]] software is made for organizing and managing multiple documents of various types. Some of them&lt;ref&gt;recent document management software products&lt;/ref&gt; have storage functions for security and back-up of valuable business information.
* [[Employee scheduling software]]- used for creating and distributing employee schedules, as well as for tracking employee hours. 
&lt;!-- Please note this is an index of Wikipedia articles.  Please do not add items to this list that do not have articles.  --&gt;
&lt;!-- Please do not put external links here.  --&gt;

== Brief history ==
{{Tone|date=February 2008}}
The essential motivation for business software is to increase profits by cutting costs or speeding the [[productive cycle]]. In the earliest days of [[White-collar worker|white-collar]] business [[automation]], large [[mainframe computer]]s were used to tackle the most tedious jobs, like bank cheque clearing and factory accounting.

Factory accounting software was among the most popular of early business software tools, and included the automation of [[general ledger]]s, fixed assets inventory ledgers, cost accounting ledgers, accounts receivable ledgers, and accounts payable ledgers (including payroll, life insurance, health insurance, federal and state insurance and retirement).

The early use of software to replace manual white-collar labor was extremely profitable, and caused a radical shift in white-collar labor. One computer might easily replace 100 white-collar 'pencil pushers', and the computer would not require any health or retirement benefits.

Building on these early successes with IBM, Hewlett-Packard and other early suppliers of business software solutions, corporate consumers demanded business software to replace the old-fashioned drafting board. CAD-CAM software (or [[computer-aided drafting]] for [[computer-aided manufacturing]]) arrived in the early 1980s. Also, [[project management software]] was so valued in the early 1980s that it might cost as much as $500,000 per copy (although such software typically had far fewer capabilities than modern project management software such as [[Microsoft Project]], which one might purchase today for under $500 per copy.)

In the early days, perhaps the most noticeable, widespread change in business software was the word processor. Because of its rapid rise, the ubiquitous IBM typewriter suddenly vanished in the 1980s as millions of companies worldwide shifted to the use of [[Word Perfect]] business software, and later, [[Microsoft Word]] software. Another vastly popular computer program for business were mathematical spreadsheet programs such as [[Lotus 1-2-3]], and later [[Microsoft Excel]].

In the 1990s business shifted massively towards [[globalism]] with the appearance of [[SAP AG|SAP]] software which coordinates a supply-chain of vendors, potentially worldwide, for the most efficient, streamlined operation of factory manufacture.

Yet nothing in the history of business software has had the global impact of the [[Internet]], with its [[email]] and websites that now serve commercial interests worldwide. Globalism in business fully arrived when the Internet became a household word.

== Application support ==
Business applications are built based on the requirements from the business users. Also, these business applications are built to use certain kind of Business transactions or data items. These business applications run flawlessly until there are no new business requirements or there is no change in underlying Business transactions. Also, the business applications run flawlessly if there are no issues with computer hardware, computer networks (Intenet/intranet), computer disks, power supplies, and various software components (middleware, database, computer programs, etc.).

Business applications can fail when an unexpected error occurs. This error could occur due to a data error (an unexpected data input or a wrong data input), an environment error (an in frastructure related error), a programming error, a human error or a work flow error. When a business application fails one needs to fix the business application error as soon as possible so that the business users can resume their work. This work of resolving business application errors is known as business application support.

=== Reporting errors ===
The Business User calls the business application support team phone number or sends an e-mail to the business application support team. The business application support team gets all the details of the error from the business user on the phone or from the e-mail. These details are then entered in a tracking software. The tracking software creates a request number and this request number is given to the business user. This request number is used to track the progress on the support issue. The request is assigned to a support team member.

=== Notification of errors ===
For critical business application errors (such as an application not available or an application not working correctly), an e-mail is sent to the entire organization or impacted teams so that they are aware of the issue. They are also provided with an estimated time for application availability.

=== Investigation or analysis of application errors ===
The business application support team member collects all the necessary information about the business software error. This information is then recorded in the support request. All of the data used by the business user is also used in the investigation. The application program is reviewed for any possible programming errors.

=== Error resolution  ===
If any similar business application errors occurred in the past then the issue resolution steps are retrieved from the support knowledge base and the error is resolved using those steps. If it is a new support error, then new issue resolution steps are created and the error is resolved. The new support error resolution steps are recorded in the knowledge base for future use. For major business application errors (critical infrastructure or application failures), a phone conference call is initiated and all required support persons/teams join the call and they all work together to resolve the error.

=== Code correction ===
If the business application error occurred due to programming errors, then a request is created for the application development team to correct programming errors. If the business user needs new features or functions in the business application, then the required analysis/design/programming/testing/release is planned and a new version of the business software is deployed.

=== Business process correction ===
If the business application error occurred due to a work flow issue or human errors during data input, then the business users are notified. Business users then review their work flow and revise it if necessary. They also modify the user guide or user instructions to avoid such an error in the future.

=== Infrastructure issue correction ===
If the business application error occurred due to infrastructure issues, then the specific infrastructure team is notified. The infrastructure team then implements permanent fixes for the issue and monitors the infrastructure to avoid the re-occurrence of the same error.

== Support follow up and internal reporting ==
The business application error tracking system is used to review all issues periodically (daily, weekly and monthly) and reports are generated to monitor the resolved issues, repeating issues, and pending issues. Reports are also generated for the IT/IS management for improvement and management of business applications.

== See also ==
{{Div col|3}}
* [[Accounting software]]
* [[Construction software]]
* [[Customer relationship management]]
* [[Decision making software]]
* [[Dashboard (business)]]
* [[Digital solutions provider]] (DSP)
* [[Document automation]]
* [[Document management system]]
* [[Electronic business]]
* [[Electronic data processing]]
* [[Electronic performance support systems]]
* [[Enterprise software]]
* [[ERP software]]
* [[Inventory software]]
* [[Legal matter management]]
* [[Management information systems]]
* [[Operational risk management]]
* [[Product lifecycle management]]
* [[Project management software]]
* [[Retail software]]
* [[Supply chain management]]
* [[Production support]]
* [[Workflow management system]]
{{Div col end}}

== References ==
{{Commons category|Business software}}
{{reflist}}

{{DEFAULTSORT:Business Software}}
[[Category:Business software| ]]

==External links==
{{Sister project links | wikt=software | commons=Special:Search/Software | b= | n= | s= | v=Computer Software | voy= |q=no}}
{{Software digital distribution platforms|state=collapsed}}
{{Authority control}}

[[Category:Computing]]
[[Category:Computer science]]</text>
      <sha1>1tqck3evkcbef5chcgvr3s7erpihzkp</sha1>
    </revision>
  </page>
  <page>
    <title>Category:Computer science by year</title>
    <ns>14</ns>
    <id>51875616</id>
    <revision>
      <id>742780656</id>
      <timestamp>2016-10-05T19:06:42Z</timestamp>
      <contributor>
        <username>Look2See1</username>
        <id>11406674</id>
      </contributor>
      <comment>[[WP:AES|←]]Created page with '{{Commonscat|Computer science}} {{Portal|Computer science}} *'''{{C|Computer science}}''' by '''{{C|Years in science|year}}''' — the {{C|History of computer sc...'</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="453">{{Commonscat|Computer science}}
{{Portal|Computer science}}
*'''{{C|Computer science}}''' by '''{{C|Years in science|year}}''' — the {{C|History of computer science|history of computer science}} and of {{C|History of computing|computing}}.

[[Category:Computer science| 01]]
[[Category:History of computer science| ]]
[[Category:History of computing| ]]
[[Category:Years in science| Computer science]]
[[Category:Technology by year| Computer science]]</text>
      <sha1>ifwbhgfxyrzwa5ammuimesrfcxrbf7z</sha1>
    </revision>
  </page>
  <page>
    <title>Wojciech Zaremba</title>
    <ns>0</ns>
    <id>51237053</id>
    <revision>
      <id>760603444</id>
      <parentid>758522627</parentid>
      <timestamp>2017-01-18T00:46:29Z</timestamp>
      <contributor>
        <ip>2603:3024:1813:ABA0:453D:6C5C:10:7955</ip>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7985">{{Infobox scientist
|name              = Wojciech Zaremba
|image             = [[File:Wojciech zaremba.png|250px]]
|image_size        = 
|caption           = 
|birth_date        = 
|birth_place       =   
|death_date        = 
|death_place       = 
|residence         = [[San Francisco, California]]
|citizenship       = 
|nationality       = [[Poland|Polish]]
|ethnicity         = 
|fields            = [[Mathematics]] &lt;br&gt; [[Computer Science]]
|workplaces        = [[OpenAI]]
|alma_mater        = [[New York University]]
|doctoral_advisor  = [[Yann LeCun]] &lt;br&gt; Rob Fergus
|academic_advisors = 
|doctoral_students = 
|notable_students  = 
|known_for         =  
|author_abbrev_bot = 
|author_abbrev_zoo = 
|influences        = 
|influenced        = 
|awards            = 
|religion          =
|signature         =  &lt;!--(filename only)--&gt;
|footnotes         = 
}}

'''Wojciech Zaremba''' (born November 30, 1988) is a Polish mathematician and computer scientist, noted for his work on [[artificial neural network]]s and [[deep learning]]. In 2015, Zaremba co-founded [[OpenAI]], with a mission to build safe [[artificial intelligence (AI)]], and ensure that its benefits are as evenly distributed as possible.&lt;ref&gt;{{Cite web|url=https://www.wired.com/2016/04/openai-elon-musk-sam-altman-plan-to-set-artificial-intelligence-free/|title=Inside OpenAI, Elon Musk’s Wild Plan to Set Artificial Intelligence Free|website=Wired|language=en-us|access-date=2016-08-26}}&lt;/ref&gt;&lt;ref name=&quot;:0&quot;&gt;{{Cite web|url=https://openai.com/blog/introducing-openai/|title=Introducing OpenAI|last=Greg|first=Brockman|date=December 11, 2015|website=OpenAI|publisher=|language=en-us|access-date=2016-12-07}}&lt;/ref&gt;

== Early life ==
Zaremba was born in 1988 in [[Kluczbork]], [[Poland]]. At a young age, he won local competitions and awards in mathematics, computer science, chemistry and physics.&lt;ref&gt;{{Cite web|url=http://opole.wyborcza.pl/opole/1,35114,4332094.html?disableRedirects=true|title=Polish mathematician among the best in the world|website=Polish newspaper &quot;wyborcza.pl&quot;|language=pl|access-date=2016-09-20}}&lt;/ref&gt; As a child, he built two functioning chemical laboratories where he completed his experiments. In his teens, his focus shifted from chemistry to computer science and mathematics. In 2007, Zaremba represented Poland in the [[International Mathematical Olympiad]], and won a silver medal.&lt;ref&gt;{{Cite web|url=https://www.imo-official.org/participant_r.aspx?id=15754|title= Results from International Mathematical Olympiad|website=IMO official website|language=en-us|access-date=2016-09-20}}&lt;/ref&gt;

Zaremba studied at the [[University of Warsaw]] and [[École Polytechnique]], and graduated in 2013 with two master's degrees in mathematics. He then began his PhD at [[New York University|New York University (NYU)]] in deep learning under the supervision of [[Yann LeCun]] and Rob Fergus.&lt;ref&gt;{{Cite web|url=http://cs.nyu.edu/~fergus/pmwiki/pmwiki.php|title=Personal website of Prof. Fergus|website=cs.nyu.edu|access-date=2016-08-26}}&lt;/ref&gt; Zaremba graduated and received his PhD in just 2.5 years,&lt;ref&gt;{{Cite web|url=https://cs.nyu.edu/media/publications/zaremba_wojciech.pdf|title=Wojciech Zaremba's PhD dissertation|website=New York University PhD Theses Archive|access-date=2016-08-26}}&lt;/ref&gt;&lt;ref&gt;{{Cite web|url=https://www.reddit.com/r/MachineLearning/comments/4n874d/woj_zarembas_thesis_on_learning_algorithms_from/|title=Reddit discussion on Wojciech Zaremba's PhD dissertation|website=Machine Learning channel at Reddit|access-date=2016-08-26}}&lt;/ref&gt; setting a record at NYU.

== Career ==
During his undergraduate years at the University of Warsaw, Zaremba completed several internships for American technology company [[Nvidia|NVIDIA]]. 

In the following years, Zaremba worked on an internship at Google where he reproduced state-of-the-art object-recognition modeling developed originally by DNNresearch. Elements of this model were used in [[Google+]]’s photo search feature.

This led to his work at [[Google Brain]],&lt;ref&gt;{{Cite web|url=http://research.google.com/teams/brain/machine-learning/|title=List of publications from Google Brain|website=Research at Google|access-date=2016-08-26}}&lt;/ref&gt; and in the following year, Zaremba spent time at Facebook AI Research&lt;ref&gt;{{Cite web|url=https://research.facebook.com/ai|title=Facebook AI Research|website=FAIR|access-date=2016-09-20}}&lt;/ref&gt; under the supervision of Prof. Rob Fergus and Prof. Yann LeCun&lt;ref&gt;{{Cite web|url=https://www.youtube.com/watch?v=GVe6kfJnRAw|title=Learning simple algorithms from examples|website=YouTube|access-date=2016-08-26}}&lt;/ref&gt;&lt;ref&gt;{{Cite web|url=https://www.crunchbase.com/person/wojciech-zaremba#/entity|title=Wojciech Zaremba's job history|website=Crunchbase|access-date=2016-08-26}}&lt;/ref&gt;&lt;ref&gt;{{Cite web|url=https://www.youtube.com/watch?v=pdODJ7JQfjo|title=Presentation from RE.WORK Deep Learning Summit 2015||website=YouTube|access-date=2016-08-26}}&lt;/ref&gt;

In 2015, Zaremba was one of the 10 co-founders of [[OpenAI]],&lt;ref&gt;{{Cite web|url=https://openai.com/about/|title=About OpenAI|website=OpenAI company website|access-date=2016-08-26}}&lt;/ref&gt;  a non-profit artificial intelligence (AI) research company. The other co-founder were  [[Ilya Sutskever]], Greg Brockman, formerly the CTO of [[Stripe (company)|Stripe]], [[Trevor Blackwell]], Vicki Cheung, [[Andrej Karpathy]], Durk Kingma, John Schulman, and Pamela Vagata.&lt;ref name=&quot;:0&quot; /&gt;
Zaremba sits on the advisory board of [http://growbots.com Growbots],&lt;ref&gt;{{Cite web|url=https://angel.co/growbots|title=Growbots' profile page|website=AngelList|access-date=2016-09-20}}&lt;/ref&gt; a [[Silicon Valley]] [[startup company]] aiming to automate sales processes with the use of machine learning and artificial intelligence.

== Honors and awards ==
*[[Aleksander Kwaśniewski]] President Scholarship for talented children&lt;ref&gt;{{Cite web|url=http://www.prezydent.pl/archiwalne-aktualnosci/rok-2000-i-starsze/art,2048,uroczystosc-wreczenia-stypendiow-z-funduszu-pomocy-mlodym-talentom-jolanty-i-aleksandra-kwasniewskich.html|title=Summary of the ceremony for granting scholarships of Jolanta and Aleksander Kwasniewski|website=Polish President website}}&lt;/ref&gt;
*Scholar of [[Polish Children's Fund]] from 2000 to 2007
*Silver Medal in 48th [[International Mathematical Olympiad]], Vietnam&lt;ref&gt;{{Cite web|url=https://www.imo-official.org/participant_r.aspx?id=15754|title= Results from International Mathematical Olympiad|website=IMO official website|language=en-us|access-date=2016-09-20}}&lt;/ref&gt;
*3rd place, 7th Czech-Polish-Slovakian Mathematical Competition 2007
*Second Prize, 15th International Mathematics Competition, Bulgaria 2008&lt;ref&gt;{{Cite web|url=http://www.imc-math.org.uk/imc2008/results2008.htm|title= Results from International Mathematical Competition|website=IMC official website|language=en-us|access-date=2016-09-20}}&lt;/ref&gt;
*26th place &lt;ref&gt;{{Cite web|url=http://vjimc.osu.cz/node/386|title=Results from 18th Vojtech Jarnik International Mathematical Competition}}&lt;/ref&gt; and 14th place,&lt;ref&gt;{{Cite web|url=http://vjimc.osu.cz/node/597|title=Results from 21st Vojtech Jarnik International Mathematical Competition}}&lt;/ref&gt; Vojtech Jarnik International Mathematical Competition 2008, 2011
*Hadamard Foundation Scholarship&lt;ref&gt;{{Cite web|url=http://95.142.164.215/en/foundation/news/283|title=Hadamard Foundation scholarship announcement|website=Hadamard Foundation website}}&lt;/ref&gt;
*Google Fellowship 2015&lt;ref&gt;{{Cite web|url=https://research.googleblog.com/2015/02/announcing-2015-north-american-google.html|title=Announcing the 2015 North American Google PhD Fellows|language=en-US|access-date=2016-08-26|website=Research at Google}}&lt;/ref&gt;

== References ==
{{reflist}}

{{DEFAULTSORT:Zaremba, Wojciech}}
[[Category:Artificial intelligence]]
[[Category:Computer science]]
[[Category:Computer scientists]]
[[Category:People from Kluczbork]]
[[Category:Polish mathematicians]]
[[Category:1988 births]]
[[Category:Living people]]</text>
      <sha1>ssu825y70acikjmhz2s4zqgza82wcce</sha1>
    </revision>
  </page>
  <page>
    <title>Critical code studies</title>
    <ns>0</ns>
    <id>34549363</id>
    <revision>
      <id>748525672</id>
      <parentid>737292157</parentid>
      <timestamp>2016-11-08T17:23:00Z</timestamp>
      <contributor>
        <username>Hooperbloob</username>
        <id>113077</id>
      </contributor>
      <comment>recat</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5155">'''Critical Code Studies''' (CCS) is an emerging academic subfield, related to [[software studies]], [[digital humanities]], [[cultural studies]], [[computer science]], [[human-computer interface]], and the DIY [[do-it-yourself]] [[maker culture]]. Its primary focus is on the cultural significance of [[computer code]], without excluding or focusing solely upon the code's functional purpose.

As introduced by Mark C. Marino (&quot;Critical Code Studies,&quot; Electronic Book Review &lt;ref&gt;{{cite web|url=http://www.electronicbookreview.com/thread/electropoetics/codology|title=Critical Code Studies - Electronic Book Review|publisher=}}&lt;/ref&gt;), critical code studies was initially a method by which scholars &quot;can read and explicate code the way we might explicate a work of literature,&quot; but the concept also draws upon Espen Aarseth's conception of a cybertext as a &quot;mechanical device for the production and consumption of verbal signs&quot; (Cybertext, 21), arguing that in order to understand a digital artifact we must also understand the constraints and capabilities of the authoring tools used by the creator of the artifact, as well as the memory storage and interface required for the user to experience the digital artifact.

Evidence that CCS has gained momentum since 2006 include an article by Matthew Kirschenbaum in the Chronicle of Higher Education,&lt;ref&gt;{{cite web|url=http://chronicle.com/article/Where-Computer-Science/14806/|title=Where Computer Science and Cultural Studies Collide|first=Matthew|last=Kirschenbaum|date=23 January 2009|publisher=|via=The Chronicle of Higher Education}}&lt;/ref&gt; CCS sessions at the Modern Language Association in 2011 that were &quot;packed&quot; with attendees,&lt;ref&gt;{{cite web|url=http://chronicle.com/article/Hard-Times-Sharpen-the-MLAs/125905/|title=Hard Times Sharpen the MLA's Lens on Labor and the Humanities|first=Jennifer|last=Howard|date=9 January 2011|publisher=|via=The Chronicle of Higher Education}}&lt;/ref&gt; several academic conferences devoted wholly to critical code studies, and a book devoted to the explication of a single line of computer code, titled ''10 PRINT CHR$(205.5+RND(1)); : GOTO 10'' (Montfort et al., MIT Press).&lt;ref&gt;{{cite web|url=https://mitpress.mit.edu/books/10-print-chr2055rnd1-goto-10|title=10 PRINT CHR$(205.5+RND(1)); : GOTO 10|publisher=}}&lt;/ref&gt;

== See also ==
* [[Software studies]]

== References ==
{{reflist}}

==Bibliography==
#Black, M. J, (2002) The Art of Code. PhD dissertation, University of Pennsylvania.
#Berry, D. M. (2011) ''The Philosophy of Software: Code and Mediation in the Digital Age'', Basingstoke: Palgrave Macmillan. [http://www.palgrave.com/products/title.aspx?pid=395958]
#Berry, D. M. (2008) ''Copy, Rip, Burn: The Politics of Copyleft and Open Source'', London: Pluto Press.
#Chopra, S. and Dexter, S. (2008) ''Decoding Liberation: The Promise of Free and Open Source Software''. Oxford: Routledge.
#Chun, W. H. K. (2008) ‘On “Sourcery,” or Code as Fetish’, Configurations, 16:299–324.
#Chun, W. H. K. (2011) ''Programmed Visions: Software and Memory'', MIT Press.
#Fuller, M. (2003) ''Behind the Blip: Essays on the Culture of Software''. London: Autonomedia.
#Fuller, M. (2008) ''Software Studies\A Lexicon''. London: MIT Press.
#Hayles, N. K. (2004) ‘Print Is Flat, Code Is Deep: The Importance of Media-Specific Analysis’, ''Poetics Today'', 25(1): 67–90.
#Heim, M. (1987) ''Electric Language: A Philosophical Discussion of Word Processing''. London: Yale University Press.
#Kirschenbaum, M. (2004) ‘Extreme Inscription: Towards a Grammatology of the Hard Drive’, ''TEXT Technology'', No. 2, pp.&amp;nbsp;91–125.
#Kirschenbaum, M. (2008) ''Mechanisms: New Media and the Forensic Imagination'', MIT Press.
#Kitchin, R. and Dodge, M. (2011) ''Code/Space: Software and Everyday Life'', MIT Press.
#Kittler, F. (1997). ''Literature, Media, Information Systems'', Johnston, J. (ed.). Amsterdam: OPA.
#Kittler, F. (1999) ''Gramophone, Film, Typewriter''. Stanford: Stanford University Press.
#Mackenzie, A. (2003) The problem of computer code: Leviathan or common power, retrieved 13/03/2010 from http://www.lancs.ac.uk/staff/mackenza/papers/code-leviathan.pdf
#Mackenzie, A. (2006) ''Cutting Code: Software and Sociality'', Oxford: Peter Lang.
#Manovich, L. (2001) ''The Language of New Media''. London: MIT Press.
#Manovich, L. (2008) Software takes Command, retrieved 03/05/2010 from https://web.archive.org/web/20110127183751/http://lab.softwarestudies.com/2008/11/softbook.html
#Manovich, L. and Douglas, J. (2009) Visualizing Temporal Patterns In Visual Media: Computer Graphics as a Research Method, retrieved 10/10/09 from http://softwarestudies.com/cultural_analytics/visualizing_temporal_patterns.pdf
#Marino, M. C. (2006) Critical Code Studies, Electronic Book Review, accessed 16 Sept 2011, http://www.electronicbookreview.com/thread/electropoetics/codology
#Montfort, N. and Bogost, I. (2009) ''Racing the Beam: The Atari Video Computer System'', London: MIT Press.
#Wardrip-Fruin, N. (2011) ''Expressive Processing''. London: MIT Press.

[[Category:Cultural studies]]
[[Category:Technology in society]]
[[Category:Computer science]]</text>
      <sha1>j9tiskj8qeu0degwsxks45fc4lutt4m</sha1>
    </revision>
  </page>
  <page>
    <title>Category:Computational fields of study</title>
    <ns>14</ns>
    <id>52242291</id>
    <revision>
      <id>750534442</id>
      <parentid>750259546</parentid>
      <timestamp>2016-11-20T10:06:25Z</timestamp>
      <contributor>
        <username>Marcocapelle</username>
        <id>14965160</id>
      </contributor>
      <comment>removed [[Category:Inductive reasoning]] using [[WP:HC|HotCat]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="706">Computational fields of study are areas of research in an existing field using the power of computation, and which are usually named for that. Computational fields of study as a group are sometimes also be referred to as [[Computational X]]&lt;ref&gt;[http://blog.stephenwolfram.com/2016/09/how-to-teach-computational-thinking/ How to Teach Computational Thinking] by [[Stephen Wolfram]], Stephen Wolfram Blog, September 7, 2016.&lt;/ref&gt;.

[[Category:Computer science]]
[[Category:Knowledge representation]]
[[Category:Applied mathematics]]
[[Category:Big data]]
[[Category:Systems theory]]
[[Category:Computing and society]]
[[Category:Systems thinking]]
[[Category:Futurology]]
[[Category:Theories of deduction]]</text>
      <sha1>23fsujue2h4bd7m7z462hf67b493etd</sha1>
    </revision>
  </page>
  <page>
    <title>Computational social choice</title>
    <ns>0</ns>
    <id>51245349</id>
    <revision>
      <id>761987392</id>
      <parentid>761986948</parentid>
      <timestamp>2017-01-26T00:29:12Z</timestamp>
      <contributor>
        <username>Citation bot</username>
        <id>7903804</id>
      </contributor>
      <minor/>
      <comment>Alter: title, url. Add: volume, doi, class, arxiv, bibcode, pages, issue, doi-broken-date, year. You can [[WP:UCB|use this bot]] yourself. [[WP:DBUG|Report bugs here]].</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="18219">{{copy edit|date=November 2016}}

{{expert needed|1=Game theory|date=November 2016}}
'''Computational social choice'''&lt;ref name=&quot;:1&quot;&gt;{{Cite book|url=https://books.google.com/books?id=nMHgCwAAQBAJ|title=Handbook of Computational Social Choice|last=Brandt|first=Felix|last2=Conitzer|first2=Vincent|last3=Endriss|first3=Ulle|last4=Lang|first4=Jérôme|last5=Procaccia|first5=Ariel D.|date=2016-04-25|publisher=Cambridge University Press|isbn=9781107060432}}&lt;/ref&gt; is a field at the intersection of [[social choice theory]] and ([[Theoretical computer science|theoretical]]) [[computer science]] (and the study of [[multi-agent system]]s). It analyzes problems arising from the aggregation of [[preference]]s of a group of agents from a computational perspective. In particular, computational social choice is concerned with the efficient computation of outcomes of [[Voting system|voting rules]], with the computational complexity of various forms of [[Tactical voting|manipulation]], and issues arising from the problem of [[Knowledge representation and reasoning|representing]] and eliciting preferences in combinatorial settings.

== Winner determination ==
The usefulness of a particular [[voting system]] can be severely limited if it takes a very long time to calculate the winner of an election. Therefore, it is important to design fast [[algorithm]]s that can evaluate a voting rule when given [[ballot]]s as input. As is common in [[Computational complexity theory|computational complexity]], an algorithm is thought to be efficient if it takes [[polynomial time]]. Many popular voting systems can be evaluated in polynomial time in a straightforward way (through counting), such as the [[Borda count]], [[approval voting]], or the [[Plurality voting system|plurality rule]]. For rules such as the [[Schulze method]]&lt;ref&gt;{{Cite journal|last=Schulze|first=Markus|date=2010-07-11|title=A new monotonic, clone-independent, reversal symmetric, and condorcet-consistent single-winner election method|url=http://link.springer.com/article/10.1007/s00355-010-0475-4|journal=Social Choice and Welfare|volume=36|issue=2|pages=267–303|doi=10.1007/s00355-010-0475-4}}&lt;/ref&gt; or [[ranked pairs]],&lt;ref&gt;{{Cite journal|last=Brill|first=Markus|last2=Fischer|first2=Felix|date=2012-01-01|title=The Price of Neutrality for the Ranked Pairs Method|url=http://dl.acm.org/citation.cfm?id=2900728.2900912|journal=Proceedings of the Twenty-Sixth AAAI Conference on Artificial Intelligence|series=AAAI'12|location=Toronto, Ontario, Canada|publisher=AAAI Press|pages=1299–1305}}&lt;/ref&gt; more sophisticated algorithms can be used to show polynomial runtime. As first pointed in an influential article in 1989,&lt;ref name=&quot;:0&quot;&gt;{{Cite journal|last=Bartholdi III|first=J.|last2=Tovey|first2=C. A.|last3=Trick|first3=M. A.|date=1989-04-01|title=Voting schemes for which it can be difficult to tell who won the election|url=http://link.springer.com/article/10.1007/BF00303169|journal=Social Choice and Welfare|volume=6|issue=2|pages=157–165|doi=10.1007/BF00303169|pmid=|access-date=|via=}}&lt;/ref&gt; certain voting systems are computationally difficult to evaluate. In particular, winner determination for the [[Kemeny–Young method|Kemeny-Young method]],&lt;ref name=&quot;:0&quot; /&gt;&lt;ref&gt;{{Cite journal|last=Hemaspaandra|first=Edith|last2=Spakowski|first2=Holger|last3=Vogel|first3=Jörg|date=2005-12-16|title=The complexity of Kemeny elections|url=http://www.sciencedirect.com/science/article/pii/S0304397505005785|journal=Theoretical Computer Science|volume=349|issue=3|pages=382–391|doi=10.1016/j.tcs.2005.08.031}}&lt;/ref&gt; [[Dodgson's method]],&lt;ref name=&quot;:0&quot; /&gt;&lt;ref&gt;{{Cite journal|last=Hemaspaandra|first=Edith|last2=Hemaspaandra|first2=Lane A.|last3=Rothe|first3=Jörg|date=1997-11-01|title=Exact Analysis of Dodgson Elections: Lewis Carroll's 1876 Voting System is Complete for Parallel Access to NP|url=http://doi.acm.org/10.1145/268999.269002|journal=J. ACM|volume=44|issue=6|pages=806–825|doi=10.1145/268999.269002}}&lt;/ref&gt; and [[Young's method]]&lt;ref&gt;{{Cite journal|last=Rothe|first=Jörg|last2=Spakowski|first2=Holger|last3=Vogel|first3=Jörg|date=2003-06-06|title=Exact Complexity of the Winner Problem for Young Elections|url=http://link.springer.com/article/10.1007/s00224-002-1093-z|journal=Theory of Computing Systems|volume=36|issue=4|pages=375–386|doi=10.1007/s00224-002-1093-z|pmid=|access-date=|via=}}&lt;/ref&gt; are all NP-hard problems. This has led to the development of [[approximation algorithm]]s&lt;ref&gt;{{Cite journal|last=Caragiannis|first=Ioannis|last2=Covey|first2=Jason A.|last3=Feldman|first3=Michal|last4=Homan|first4=Christopher M.|last5=Kaklamanis|first5=Christos|last6=Karanikolas|first6=Nikos|last7=Procaccia|first7=Ariel D.|last8=Rosenschein|first8=Jeffrey S.|date=2012-08-01|title=On the approximability of Dodgson and Young elections|url=http://www.sciencedirect.com/science/article/pii/S0004370212000434|journal=Artificial Intelligence|volume=187|pages=31–51|doi=10.1016/j.artint.2012.04.004}}&lt;/ref&gt;&lt;ref&gt;{{Cite journal|last=Ailon|first=Nir|last2=Charikar|first2=Moses|last3=Newman|first3=Alantha|date=2008-11-01|title=Aggregating Inconsistent Information: Ranking and Clustering|url=http://doi.acm.org/10.1145/1411509.1411513|journal=J. ACM|volume=55|issue=5|pages=23:1–23:27|doi=10.1145/1411509.1411513}}&lt;/ref&gt; and [[Parameterized complexity|fixed-parameter tractable algorithms]].&lt;ref&gt;{{Cite book|url=http://link.springer.com/chapter/10.1007/978-3-540-68880-8_8|title=Fixed-Parameter Algorithms for Kemeny Scores|last=Betzler|first=Nadja|last2=Fellows|first2=Michael R.|last3=Guo|first3=Jiong|last4=Niedermeier|first4=Rolf|last5=Rosamond|first5=Frances A.|date=2008-06-23|publisher=Springer Berlin Heidelberg|isbn=9783540688655|editor-last=Fleischer|editor-first=Rudolf|series=Lecture Notes in Computer Science|pages=60–71|doi=10.1007/978-3-540-68880-8_8|editor-last2=Xu|editor-first2=Jinhui}}&lt;/ref&gt;

== Hardness of manipulation ==
By the [[Gibbard–Satterthwaite theorem|Gibbard-Satterthwaite theorem]], all non-trivial voting rules can be [[Tactical voting|manipulated]] in the sense that voters can sometimes achieve a better outcome by misrepresenting their preferences, that is, they submit a non-truthful [[ballot]] to the voting system. Much effort in social choice theory has been invested in finding ways to circumvent this result. One such possibility was proposed by Bartholdi, Tovey, and Trick in 1989&lt;ref&gt;{{Cite journal|last=Bartholdi|first=J. J.|last2=Tovey|first2=C. A.|last3=Trick|first3=M. A.|title=The computational difficulty of manipulating an election|url=http://link.springer.com/article/10.1007/BF00295861|journal=Social Choice and Welfare|volume=6|issue=3|pages=227–241|doi=10.1007/BF00295861|year=1989}}&lt;/ref&gt; and is based on [[computational complexity theory]]. They considered a voting rule called [[Copeland's method|second-order Copeland rule]] (which can be evaluated in polynomial time), and proved that it is [[NP-completeness|NP-complete]] for a voter to decide, given knowledge of how everyone else has voted, whether it is possible to manipulate in such a way as to make some favored candidate the winner. The same property holds for [[single transferable vote]].&lt;ref&gt;{{Cite journal|last=Bartholdi|first=John J.|last2=Orlin|first2=James B.|title=Single transferable vote resists strategic voting|url=http://link.springer.com/article/10.1007/BF00183045|journal=Social Choice and Welfare|volume=8|issue=4|pages=341–354|doi=10.1007/BF00183045|year=1991}}&lt;/ref&gt;

These results show that (assuming the widely believed hypothesis that [[P versus NP problem|P ≠ NP]]) there are instances where polynomial time is not enough to establish whether a beneficial manipulation is possible. In this sense, the voting rules that come with an NP-hard manipulation problem are &quot;resistant&quot; to manipulation. One should note that these results only concern the [[Worst-case execution time|worst-case]]: it might well be possible that a manipulation problem is usually easy to solve, and only requires superpolynomial time on very unusual inputs.&lt;ref&gt;{{Cite journal|last=Faliszewski|first=Piotr|last2=Procaccia|first2=Ariel D.|date=2010-09-23|title=AI's War on Manipulation: Are We Winning?|url=http://www.aaai.org/ojs/index.php/aimagazine/article/view/2314|journal=AI Magazine|volume=31|issue=4|pages=53–64|doi=10.1609/aimag.v31i4.2314|doi-broken-date=2017-01-26}}&lt;/ref&gt;

== Other topics ==
* '''[[Tournament solution]]s.''' A tournament solution is a rule that assigns to every [[Tournament (graph theory)|tournament]] a set of winners. Since a preference profile induces a tournament through its [[Majority|majority relation]], every tournament solution can also be seen as a voting rule which only uses information about the outcomes of pairwise majority contests.&lt;ref&gt;{{Cite journal|last=Fishburn|first=P.|date=1977-11-01|title=Condorcet Social Choice Functions|url=http://epubs.siam.org/doi/abs/10.1137/0133030|journal=SIAM Journal on Applied Mathematics|volume=33|issue=3|pages=469–489|doi=10.1137/0133030}}&lt;/ref&gt; Many tournament solutions have been proposed,&lt;ref&gt;{{Cite book|url=https://books.google.com/?id=P9Q-AAAAIAAJ|title=Topics on tournaments|last=Moon|first=John W.|date=1968-01-01|publisher=Holt, Rinehart and Winston}}&lt;/ref&gt; and computational social choice has studied the complexity of the associated winner determination problems.&lt;ref name=&quot;:1&quot; /&gt; 
* '''Preference restrictions.''' Restricted preference domains, such as [[Single peaked preferences|single-peaked]]&lt;ref&gt;{{Cite journal|last=Black|first=Duncan|date=1948-01-01|title=On the Rationale of Group Decision-making|jstor=1825026|journal=Journal of Political Economy|volume=56|issue=1|pages=23–34}}&lt;/ref&gt; or [[Single crossing condition|single-crossing]]&lt;ref&gt;{{Cite journal|last=Rothstein|first=P.|date=1990-12-01|title=Order restricted preferences and majority rule|url=http://link.springer.com/article/10.1007/BF01376281|journal=Social Choice and Welfare|volume=7|issue=4|pages=331–342|doi=10.1007/BF01376281}}&lt;/ref&gt; preferences, are an important area of study in [[social choice theory]], since preferences from these domains avoid the [[Voting paradox|Condorcet paradox]]&lt;ref&gt;{{Cite book|url=https://books.google.com/books?id=y_rkX6QWOYMC|title=Social Choice and Individual Values|last=Arrow|first=Kenneth J.|date=2012-06-26|publisher=Yale University Press|isbn=0300186983}}&lt;/ref&gt;&lt;ref&gt;{{Cite journal|last=Sen|first=Amartya|last2=Pattanaik|first2=Prasanta K|date=1969-08-01|title=Necessary and sufficient conditions for rational choice under majority decision|url=http://www.sciencedirect.com/science/article/pii/0022053169900209|journal=Journal of Economic Theory|volume=1|issue=2|pages=178–202|doi=10.1016/0022-0531(69)90020-9}}&lt;/ref&gt; and thus can circumvent impossibility results like [[Arrow's impossibility theorem|Arrow's]] and the [[Gibbard–Satterthwaite theorem|Gibbard-Satterthwaite theorem]]. From a computational perspective, such domain restrictions are useful to speed up winner determination problems,&lt;ref&gt;{{Cite journal|last=Elkind|first=Edith|last2=Lackner|first2=Martin|last3=Peters|first3=Dominik|date=2016-07-01|title=Preference Restrictions in Computational Social Choice: Recent Progress|url=http://www.ijcai.org/Proceedings/16/Papers/601.pdf|journal=Proceedings of the 25th International Conference on Artificial Intelligence|series=IJCAI'16|location=New York|publisher=AAAI Press|volume=|issue=|pages=4062–4065|doi=|isbn=|pmid=|access-date=|via=}}&lt;/ref&gt; both computationally hard single-winner&lt;ref name=&quot;:2&quot;&gt;{{Cite journal|last=Brandt|first=Felix|last2=Brill|first2=Markus|last3=Hemaspaandra|first3=Edith|last4=Hemaspaandra|first4=Lane|date=2015-01-01|title=Bypassing Combinatorial Protections: Polynomial-Time Algorithms for Single-Peaked Electorates|url=http://dx.doi.org/10.1613/jair.4647|journal=Journal of Artificial Intelligence Research|volume=53|issue=|doi=10.1613/jair.4647|pmid=|access-date=|via=|doi-broken-date=2017-01-26}}&lt;/ref&gt; and  multi-winner rules&lt;ref&gt;{{Cite journal|last=N.|first=Betzler,|last2=A.|first2=Slinko,|last3=J.|first3=Uhlmann,|date=2013-01-01|title=On the Computation of Fully Proportional Representation|url=http://www.jair.org/papers/paper3896.html|journal=Journal of Artificial Intelligence Research|volume=47|issue=2013|pages=475–519|bibcode=2014arXiv1402.0580B|arxiv=1402.0580|class=cs.GT|doi=10.1613/jair.3896|doi-broken-date=2017-01-26}}&lt;/ref&gt;&lt;ref&gt;{{Cite journal|last=Skowron|first=Piotr|last2=Yu|first2=Lan|last3=Faliszewski|first3=Piotr|last4=Elkind|first4=Edith|date=2015-03-02|title=The complexity of fully proportional representation for single-crossing electorates|url=http://www.sciencedirect.com/science/article/pii/S0304397514010111|journal=Theoretical Computer Science|volume=569|pages=43–57|doi=10.1016/j.tcs.2014.12.012}}&lt;/ref&gt; can be computed in polynomial time when preferences are structured appropriately. On the other hand, manipulation problem also tend to be easy on these domains,&lt;ref name=&quot;:2&quot; /&gt;&lt;ref&gt;{{Cite journal|last=Faliszewski|first=Piotr|last2=Hemaspaandra|first2=Edith|last3=Hemaspaandra|first3=Lane A.|last4=Rothe|first4=Jörg|date=2011-02-01|title=The shield that never was: Societies with single-peaked preferences are more open to manipulation and control|url=http://www.sciencedirect.com/science/article/pii/S0890540110001525|journal=Information and Computation|volume=209|issue=2|pages=89–107|doi=10.1016/j.ic.2010.09.001}}&lt;/ref&gt; so complexity shields against manipulation are less effective. Another computational problem associated with preference restrictions is that of recognizing when a given preference profile belongs to some restricted domain. This task is polynomial time solvable in many cases, including for single-peaked&lt;ref name=&quot;:3&quot;&gt;{{Cite journal|last=Doignon|first=J. P.|last2=Falmagne|first2=J. C.|date=1994-03-01|title=A Polynomial Time Algorithm for Unidimensional Unfolding Representations|url=http://www.sciencedirect.com/science/article/pii/S0196677484710108|journal=Journal of Algorithms|volume=16|issue=2|pages=218–233|doi=10.1006/jagm.1994.1010}}&lt;/ref&gt;&lt;ref&gt;{{Cite journal|last=Escoffier|first=Bruno|last2=Lang|first2=Jérôme|last3=Öztürk|first3=Meltem|date=2008-01-01|title=Single-peaked Consistency and Its Complexity|url=http://dl.acm.org/citation.cfm?id=1567281.1567363|journal=Proceedings of the 2008 Conference on ECAI 2008: 18th European Conference on Artificial Intelligence|location=Amsterdam, The Netherlands, The Netherlands|publisher=IOS Press|pages=366–370|isbn=9781586038915}}&lt;/ref&gt; and single-crossing&lt;ref name=&quot;:3&quot; /&gt; preferences, but can be hard for more general classes.&lt;ref&gt;{{Cite arxiv|last=Peters|first=Dominik|date=2016-02-25|title=Recognising Multidimensional Euclidean Preferences|eprint=1602.08109|class=cs.GT}}&lt;/ref&gt;
* '''Multiwinner elections.''' While most traditional voting rules focus on selecting a single winner, many situations require selecting multiple winners. This is the case when a fixed-size [[parliament]] or a [[committee]] is to be elected, though multiwinner voting rules can also be used to select a set of [[Recommender system|recommendations]] or [[Facility location problem|facilities]] or a shared bundle of items. Work in computational social choice has focussed on defining such voting rules,&lt;ref&gt;{{Cite journal|last=Skowron|first=Piotr|last2=Faliszewski|first2=Piotr|last3=Lang|first3=Jerome|date=2015-01-01|title=Finding a Collective Set of Items: From Proportional Multirepresentation to Group Recommendation|url=http://dl.acm.org/citation.cfm?id=2886521.2886617|journal=Proceedings of the Twenty-Ninth AAAI Conference on Artificial Intelligence|volume=1402|series=AAAI'15|location=Austin, Texas|publisher=AAAI Press|pages=2131–2137|isbn=0262511290|bibcode=2014arXiv1402.3044S|arxiv=1402.3044|class=cs.GT}}&lt;/ref&gt; understanding their properties,&lt;ref&gt;{{Cite journal|last=Elkind|first=Edith|last2=Faliszewski|first2=Piotr|last3=Skowron|first3=Piotr|last4=Slinko|first4=Arkadii|date=2014-01-01|title=Properties of Multiwinner Voting Rules|url=http://dl.acm.org/citation.cfm?id=2615731.2615743|journal=Proceedings of the 2014 International Conference on Autonomous Agents and Multi-agent Systems|volume=1506|series=AAMAS '14|location=Richland, SC|publisher=International Foundation for Autonomous Agents and Multiagent Systems|pages=53–60|isbn=9781450327381|bibcode=2015arXiv150602891E|arxiv=1506.02891|class=cs.GT}}&lt;/ref&gt; and studying the complexity of the associated winner determination problems.&lt;ref&gt;{{Cite journal|last=Procaccia|first=Ariel D.|last2=Rosenschein|first2=Jeffrey S.|last3=Zohar|first3=Aviv|date=2007-04-19|title=On the complexity of achieving proportional representation|url=http://link.springer.com/article/10.1007/s00355-007-0235-2|journal=Social Choice and Welfare|volume=30|issue=3|pages=353–362|doi=10.1007/s00355-007-0235-2}}&lt;/ref&gt;&lt;ref&gt;{{Cite journal|last=Lu|first=Tyler|last2=Boutilier|first2=Craig|date=2011-01-01|title=Budgeted Social Choice: From Consensus to Personalized Decision Making|journal=Proceedings of the Twenty-Second International Joint Conference on Artificial Intelligence|series=IJCAI'11|location=Barcelona, Catalonia, Spain|publisher=AAAI Press|pages=280–286|doi=10.5591/978-1-57735-516-8/IJCAI11-057|isbn=9781577355137|doi-broken-date=2017-01-26}}&lt;/ref&gt;&lt;ref&gt;{{Cite journal|last=Skowron|first=Piotr|last2=Faliszewski|first2=Piotr|last3=Slinko|first3=Arkadii|date=2015-05-01|title=Achieving fully proportional representation: Approximability results|url=http://www.sciencedirect.com/science/article/pii/S0004370215000132|journal=Artificial Intelligence|volume=222|pages=67–103|doi=10.1016/j.artint.2015.01.003}}&lt;/ref&gt;

== See also ==
* [[Algorithmic game theory]]
* [[Algorithmic mechanism design]]
* [[Hedonic game]]s
* [[Fair cake-cutting|Cake-cutting]]
* [[Fair division]]

== References ==
{{Reflist|2}}

== External links ==
* [http://www.illc.uva.nl/COMSOC/ The COMSOC website], offering a collection of materials related to computational social choice, such as academic workshops, PhD theses, and a mailing list.

[[Category:Articles created via the Article Wizard]]
[[Category:Social choice theory]]
[[Category:Voting systems]]
[[Category:Computer science]]</text>
      <sha1>8fi18p8lzpsiprjcgksquwor3qiff2g</sha1>
    </revision>
  </page>
  <page>
    <title>Category:Computer science by country</title>
    <ns>14</ns>
    <id>52508038</id>
    <revision>
      <id>753543150</id>
      <timestamp>2016-12-07T20:23:17Z</timestamp>
      <contributor>
        <username>Mazuritz</username>
        <id>16361928</id>
      </contributor>
      <comment>{{container category}} {{Commons cat|Computer science by country}}  [[Category:Computer science| ]] [[Category:Science and technology by country]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="146">{{container category}}
{{Commons cat|Computer science by country}}

[[Category:Computer science| ]]
[[Category:Science and technology by country]]</text>
      <sha1>eyxwofkftoba27qp1s29h1o688gos40</sha1>
    </revision>
  </page>
  <page>
    <title>Programmer</title>
    <ns>0</ns>
    <id>23716</id>
    <revision>
      <id>770968667</id>
      <parentid>770968665</parentid>
      <timestamp>2017-03-18T18:55:23Z</timestamp>
      <contributor>
        <username>ClueBot NG</username>
        <id>13286072</id>
      </contributor>
      <minor/>
      <comment>Reverting possible vandalism by [[Special:Contribs/72.27.143.161|72.27.143.161]] to version by Snori. [[WP:CBFP|Report False Positive?]] Thanks, [[WP:CBNG|ClueBot NG]]. (2976104) (Bot)</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="17906">{{about|people who write computer software}}
{{For|someone who performs coding in the social sciences|Coding (social sciences)}}
{{Redirect|Coder|the settlement in Pennsylvania|Coder, Pennsylvania|other uses|Encoder}}

[[File:Bundesarchiv B 145 Bild-F031434-0006, Aachen, Technische Hochschule, Rechenzentrum.jpg|thumb|Student programmers at the [[RWTH Aachen University]] in [[Aachen]], Germany in 1970]]
A '''programmer''', '''computer programmer''', '''developer''', '''dev''', '''coder''', or '''software engineer''' is a person who writes [[computer software]]. The term ''computer programmer'' can refer to a specialist in one area of [[computer programming]] or to a generalist who writes code for many kinds of software. One who practices or professes a formal approach to programming may also be known as a '''programmer analyst'''. 

A programmer's primary [[computer language]] ([[Assembly language|Assembly]], [[COBOL]], [[C (programming language)|C]], [[C++]], [[C Sharp (programming language)|C#]], [[Java (programming language)|Java]], [[Lisp (programming language)|Lisp]], [[Python programming language|Python]], etc.) is often prefixed to these titles, and those who work in a [[World Wide Web|web]] environment often prefix their titles with ''web''. 

A range of occupations, including: [[software developer]], [[web developer]], mobile applications developer, embedded [[firmware]] developer, [[software engineer]], [[computer scientist]], or [[software analyst]], while they do involve programming, also require a range of other skills. The use of the simple term ''programmer'' for these positions is sometimes considered an insulting or derogatory oversimplification.&lt;ref&gt;{{cite news|title=No Programmers |url=http://www.ericsink.com/No_Programmers.html}}&lt;/ref&gt;&lt;ref&gt;{{cite news|title=Developer versus programmer |url=http://codebetter.com/blogs/raymond.lewallen/archive/2005/02/22/55812.aspx}}&lt;/ref&gt;&lt;ref&gt;{{cite news|title=Developers AND Programmers |url=http://weblogs.asp.net/miked/archive/2006/10/13/_2200_Developers_2200_-and-_2200_Programmers_2200_.aspx}}&lt;/ref&gt;&lt;ref&gt;{{cite news|title=Programmer vs. Developer vs. Software Engineer |url=http://discuss.joelonsoftware.com/default.asp?joel.3.112837.37}}&lt;/ref&gt;&lt;ref&gt;{{cite news|title=Programmer vs. Developer vs. Software Engineer |url=http://www.xtremevbtalk.com/archive/index.php/t-233780.html}}&lt;/ref&gt;

==History==
[[Image:Ada Lovelace portrait.jpg|thumb|200px|right|[[Ada Lovelace]] is considered by many as the first computer programmer.&lt;ref&gt;{{cite book|first=J.|last=Fuegi|first2=J.|last2=Francis|title=Lovelace &amp; Babbage and the creation of the 1843 'notes'|journal=Annals of the History of Computing|volume=25|issue=4 |year=2003|pages=18–26|doi=10.1109/MAHC.2003.1253887}}&lt;/ref&gt;]]
British countess and mathematician [[Ada Lovelace]] is often considered the first computer programmer, as she was the first to publish an [[algorithm]] intended for implementation on [[Charles Babbage]]'s [[analytical engine]], in October 1842, intended for the calculation of [[Bernoulli number]]s.&lt;ref&gt;J. Fuegi and J. Francis, &quot;Lovelace &amp; Babbage and the creation of the 1843 'notes'.&quot; Annals of the History of Computing 25 #4 (October–December 2003): 19, 25. [http://dx.doi.org/10.1109/MAHC.2003.1253887 Digital Object Identifier]&lt;/ref&gt;  Because Babbage's machine was never completed to a functioning standard in her time, she never saw this algorithm run.

The first person to run a program on a functioning modern electronically based computer was [[computer scientist]] [[Konrad Zuse]], in 1941.

The [[ENIAC]] programming team, consisting of [[Kathleen Antonelli|Kay McNulty]], [[Jean Bartik|Betty Jennings]], [[Betty Holberton|Betty Snyder]], [[Marlyn Meltzer|Marlyn Wescoff]], [[Frances Spence|Fran Bilas]] and [[Ruth Teitelbaum|Ruth Lichterman]] were the first regularly working programmers.&lt;ref&gt;{{cite web|url=http://eniacprogrammers.org/ |title=ENIAC Programmers Project |publisher=Eniacprogrammers.org |date= |accessdate=2010-10-03}}&lt;/ref&gt;&lt;ref&gt;{{cite web|url=http://abcnews.go.com/Technology/story?id=3951187&amp;page=1 |title=ABC News: First Computer Programmers Inspire Documentary |publisher=Abcnews.go.com |date=2007-12-04 |accessdate=2010-10-03}}&lt;/ref&gt;

International Programmers' Day is celebrated annually on 7 January.&lt;ref&gt;{{cite web|url=http://www.internationalprogrammersday.org |title=International Programmers' Day}}&lt;/ref&gt;  In 2009, the [[government of Russia]] decreed a professional annual holiday known as [[Programmers' Day]] to be celebrated on 13 September (12 September in leap years). It had also been an unofficial international holiday before that.

==Nature of the work==
:''Some of this section is from the [http://www.bls.gov/oco/ocos110.htm Occupational Outlook Handbook], 2006–07 Edition, which is in the [[public domain]] as a [[work of the United States Government]].''

Computer programmers write, test, [[debug]], and maintain the detailed instructions, called [[computer programs]], that computers must follow to perform their functions. Programmers also conceive, design, and test logical structures for solving problems by computer. Many technical innovations in programming&amp;nbsp;— advanced computing technologies and sophisticated new languages and programming tools&amp;nbsp;— have redefined the role of a programmer and elevated much of the programming work done today. Job titles and descriptions may vary, depending on the organization.

Programmers work in many settings, including corporate [[information technology]] (&quot;IT&quot;) departments, big [[software companies]], small service firms and government entities of all sizes. Many professional programmers also work for consulting companies at client sites as [[Independent contractor|contractors]]. [[License|Licensing]] is not typically required to work as a programmer, although [[professional certification]]s are commonly held by programmers. Programming is widely considered a [[profession]] (although some{{Who|date=March 2011}} authorities disagree on the grounds that only careers with legal licensing requirements count as a profession).

Programmers' work varies widely depending on the type of business for which they are writing programs. For example, the instructions involved in updating financial records are very different from those required to duplicate conditions on an aircraft for pilots training in a flight simulator. Simple programs can be written in a few hours, more complex ones may require more than a year of work, while others are never considered 'complete' but rather are continuously improved as long as they stay in use. In most cases, several programmers work together as a team under a senior programmer’s supervision.
[[File:Programmer writing code with Unit Tests.jpg|thumb|225px|right|A computer programmer editing the [[source code]] of a piece of [[software]].]]

Programmers write programs according to the specifications determined primarily by more senior programmers and by [[systems analyst]]s. After the design process is complete, it is the job of the programmer to convert that design into a logical series of instructions that the computer can follow. The programmer codes these instructions in one of many programming languages. Different programming languages are used depending on the purpose of the program. [[COBOL]], for example, is commonly used for business applications that typically run on [[Mainframe computer|mainframe]] and [[minicomputer|midrange]] computers, whereas [[Fortran]] is used in science and engineering. [[C++]] is widely used for both scientific and business applications. [[Java (programming language)|Java]], [[C Sharp (programming language)|C#]], [[Visual Basic|VB]]  and [[PHP]] are popular programming languages for Web and business applications. Programmers generally know more than one programming language and, because many languages are similar, they often can learn new languages relatively easily. In practice, programmers often are referred to by the language they know, e.g. as ''Java programmers'', or by the type of function they perform or environment in which they work: for example, ''[[database]] programmers'', ''mainframe programmers'', or [[Web developer]]s.

When making changes to the [[source code]] that programs are made up of, programmers need to make other programmers aware of the task that the routine is to perform. They do this by inserting comments in the [[source code]] so that others can understand the program more easily and by [[Software documentation|documenting their code]]. To save work, programmers often use [[Library (computing)|libraries]] of basic code that can be modified or customized for a specific application. This approach yields more reliable and consistent programs and increases programmers' productivity by eliminating some routine steps.

===Testing and debugging===
Programmers test a program by running it and looking for [[Software bug|bugs]] (errors). As they are identified, the programmer usually makes the appropriate corrections, then rechecks the program until an acceptably low level and severity of bugs remain. This process is called [[Software testing|testing]] and [[debugging]]. These are important parts of every programmer's job. Programmers may continue to fix these problems throughout the life of a program. Updating, repairing, modifying, and expanding existing programs is sometimes called ''maintenance programming''. Programmers may contribute to [[user guide]]s and [[online help]], or they may work with [[technical writer]]s to do such work.

===Application versus system programming===
Computer programmers often are grouped into two broad types: application programmers and systems programmers. Application programmers write programs to handle a specific job, such as a program to track inventory within an organization. They also may revise existing packaged software or customize generic applications which are frequently purchased from [[independent software vendor]]s. Systems programmers, in contrast, write programs to maintain and control computer systems software, such as [[operating system]]s and [[database management system]]s. These workers make changes in the instructions that determine how the network, workstations, and [[Central processing unit|CPU]] of the system handle the various jobs they have been given and how they communicate with peripheral equipment such as [[Computer printer|printers]] and [[Data storage device|disk drives]].

===Types of software===
Programmers in software development companies may work directly with experts from various fields to create software&amp;nbsp;– either programs designed for specific clients or packaged software for general use&amp;nbsp;– ranging from [[video game]]s to educational software to programs for [[desktop publishing]] and financial planning. Programming of packaged software constitutes one of the most rapidly growing segments of the computer services industry. Some companies or organizations – even small ones – have set up their own IT team to ensure the design and development of in-house software to answer to very specific needs from their internal end-users, especially when existing software are not suitable or too expensive. This is for example the case in [[research laboratories]].{{citation needed|date=May 2014}}

In some organizations, particularly small ones, people commonly known as ''programmer analysts'' are responsible for both the systems analysis and the actual programming work. The transition from a mainframe environment to one that is based primarily on [[personal computers]] (PCs) has blurred the once rigid distinction between the programmer and the user. Increasingly, adept end users are taking over many of the tasks previously performed by programmers. For example, the growing use of packaged software, such as spreadsheet and database management software packages, allows users to write simple programs to access data and perform calculations.{{citation needed|date=May 2014}}

In addition, the rise of the Internet has made [[web development]] a huge part of the programming field. Currently more software applications are [[web application]]s that can be used by anyone with a [[web browser]].{{citation needed|date=May 2014}} Examples of such applications include the [[Google]] search service, the [[Outlook.com]] e-mail service, and the [[Flickr]] photo-sharing service.

Programming editors, also known as [[source code editor]]s, are text editors that are specifically designed for programmers or developers for writing the source code of an application or a program. Most of these editors include features useful for programmers, which may include color [[syntax highlighting]], auto indentation, [[auto-complete]], bracket matching, [[Syntax checker|syntax check]], and allows [[plug-in (computing)|plug-in]]s. These features aid the users during coding, [[debugging]] and testing.{{citation needed|date=May 2014}}

==Globalization==
{{globalize/US|date=December 2010}}

===Market changes in the UK===
According to BBC News, 17% of computer science students could not find work in their field 6 months after graduation in 2009 which was the highest rate of the university subjects surveyed while 0% of medical students were unemployed in the same survey.&lt;ref&gt;[http://www.bbc.co.uk/news/10477551 &quot;'One in 10' UK graduates unemployed&quot;] from the [[BBC]]&lt;/ref&gt; The UK category system does, however, class such degrees as [[information technology]] and [[game design]] as 'computer science', industries in which jobs can be extremely difficult to find, somewhat inflating the actual figure.&lt;ref&gt;[http://www.plymouth.ac.uk/pages/view.asp?page=23727] ATAS classifications (University of Plymouth)&lt;/ref&gt;

===Market changes in the US===
Computer programming, [[offshore outsourcing]], and [[Foreign Worker Visa]]s became a controversial topic after the crash of the [[dot-com bubble]] left many programmers without work or with lower wages. Programming was even mentioned in the 2004 US Presidential debate on the topic of [[offshore outsourcing]].&lt;ref&gt;{{Cite web|url=http://www.debates.org/index.php?page=october-8-2004-debate-transcript|title=CPD: October 8, 2004 Debate Transcript|website=www.debates.org|access-date=2017-02-13}}&lt;/ref&gt;

Large companies claim there is a [[skills shortage]] with regard to programming talent. However, US programmers and unions counter that large companies are exaggerating their case in order to obtain cheaper programmers from developing countries and to avoid paying for training in very specific technologies.&lt;ref&gt;[http://heather.cs.ucdavis.edu/MigLtrs.pdf] Migration Letters, Volume: 10, No: 2, pp. 211 – 228 {{ISSN|1741-8984}} &amp; e{{ISSN|1741-8992}}&lt;/ref&gt; Other reasons for claiming skill shortages by employers is the combining of several disparate skills previously held by several programmers into fewer [[Mechatronics|multifaceted]]  positions that are more unlikely to have [[Purple squirrel|&quot;qualified&quot; candidates]].&lt;ref&gt;&quot;Purple Squirrels and the Reserve Army of the Unemployed&quot; Paul Solman http://www.pbs.org/newshour/making-sense/purple-squirrels-and-the-reser/ [[PBS]]August 15, 2012  accessdate  = 2016-06-10&lt;/ref&gt;

Enrollment in computer-related degrees in US has dropped recently due to lack of general interests in science and mathematics and also out of an apparent fear that programming will be subject to the same pressures as manufacturing and agriculture careers.&lt;ref&gt;Theresa Beaubouef and John Mason, [http://dl.acm.org/citation.cfm?id=1083474 Why the high attrition rate for computer science students: some thoughts and observations.], ACM SIGCSE Bulletin, 2005&lt;/ref&gt; This situation has resulted in confusion about whether the US economy is entering a &quot;post-[[Quaternary sector of the economy|information]] age&quot; and the nature of US [[comparative advantage]]s. Most academic institutions have an [[Institutional research]] office that keep past statistics of degrees conferred which show several dips and rises in Computer Science degrees over the past 30 years. The overall trend shows a slightly overall decline in growth (especially when compared to other STEM degree growth) since certain peaks of [[Early 1980s recession in the United States|1986]], [[Early 1990s recession in the United States|1992]], [[Dot-com bubble|2002]], and [[Great Recession|2008]] showing periods of flat growth or even declines. In addition the U.S. Bureau of Labor Statistics Occupational Outlook 2014-24 is -8% (a decline in their words) for Computer Programmers because Computer programming can be done from anywhere in the world, so companies sometimes hire programmers in countries where wages are lower.&lt;ref&gt;https://www.bls.gov/ooh/computer-and-information-technology/computer-programmers.htm&lt;/ref&gt;

==See also==
{{Portal|Computer programming}}
*[[Game programmer]]
*[[List of programmers]]
*[[Software development process]]
*[[Software engineering]]
*[[System administrator]]
{{Clear}}

==References==
{{Reflist|30em}}
.

==Further reading==
* [[Gerald Weinberg|Weinberg, Gerald M.]], ''The Psychology of Computer Programming'', New York: Van Nostrand Reinhold, 1971
* An experiential study of the nature of programming work: Lucas, Rob. [http://www.newleftreview.org/?view=2836 &quot;Dreaming in Code&quot;] ''New Left Review'' 62, March–April 2010, pp.&amp;nbsp;125–132.

==External links==
{{Wiktionary|programmer|coder}}
* [http://www.ideosphere.com/fx-bin/Claim?claim=ITJOBS &quot;The Future of IT Jobs in America&quot; article]
* [http://samizdat.mines.edu/howto/HowToBeAProgrammer.html How to be a programmer] - An overview of the challenges of being a programmer
* The US Department of Labor's description of &quot;[http://www.bls.gov/ooh/computer-and-information-technology/computer-programmers.htm Computer Programmers]&quot;

[[Category:Computer occupations]]
[[Category:Computer programmers]]
[[Category:Computer science]]</text>
      <sha1>9ioes86kedxknmitp0baczfdp4gj60m</sha1>
    </revision>
  </page>
  <page>
    <title>Computer science in sport</title>
    <ns>0</ns>
    <id>25852537</id>
    <revision>
      <id>758980090</id>
      <parentid>756786150</parentid>
      <timestamp>2017-01-08T16:35:23Z</timestamp>
      <contributor>
        <username>BlackJack</username>
        <id>359672</id>
      </contributor>
      <comment>removed [[Category:Sports]]; added [[Category:Sports science]] using [[WP:HC|HotCat]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9511">'''Computer science in sport''' is an interdisciplinary discipline that has its goal in combining the theoretical as well as practical aspects and methods of the areas of [[Information technology|informatics]] and [[sport science]]. The main emphasis of the [[interdisciplinarity]] is placed on the application and use of computer-based but also mathematical techniques in sport science, aiming in this way at the support and advancement of theory and practice in sports.&lt;ref&gt;{{cite web|author1=Daniel Link |author2=Martin Lames |title=Sport Informatics – Historical Roots, Interdisciplinarity and Future Developments|year=2009}} IJCSS Volume 8 Edition 2, 68-87.&lt;/ref&gt; The reason why [[computer science]] has become an important partner for sport science is mainly connected with &quot;the fact that the use of data and media, the design of models, the analysis of systems etc. increasingly requires the support of suitable tools and concepts which are developed and available in computer science&quot;.&lt;ref&gt;{{cite web|author=Arnold Baca|title=Computer science in sport: an overview of history, present fields and future applications (part I)|year=2006}} IJCSS Special Edition 2/2006, 25-35.&lt;/ref&gt;

== Historical background ==
Going back in history, computers in sports were used for the first time in the 1960s, when the main purpose was to accumulate sports information. [[Database]]s were created and expanded in order to launch documentation and dissemination of publications like articles or books that contain any kind of knowledge related to sports science. Until the mid-1970s also the first organization in this area called IASI (International Association for Sports Information) was formally established. Congresses and meetings were organized more often with the aim of standardization and rationalization of sports documentation. Since at that time this area was obviously less computer-oriented, specialists talk about sports information rather than sports informatics when mentioning the beginning of this field of science.

Based on the progress of computer science and the invention of more powerful computer hardware in the 1970s, also the real history of computer science in sport began.&lt;ref&gt;{{cite web|author=Jürgen Perl|title=Computer science in sport: an overview of history, present fields and future applications (part II)|year=2006}} IJCSS Special Edition 2/2006, 36-46.&lt;/ref&gt; This was as well the first time when this term was officially used and the initiation of a very important evolution in sports science.

In the early stages of this area statistics on biomechanical data, like different kinds of forces or rates, played a major role. Scientists started to analyze sports games by collecting and looking at such values and features in order to interpret them. Later on, with the continuous improvement of computer hardware - in particular microprocessor speed – many new scientific and computing paradigms were introduced, which were also integrated in computer science in sport. Specific examples are [[Computer model|modeling]] as well as [[simulation]], but also [[pattern recognition]], design, and (sports) [[data mining]].&lt;ref&gt;{{cite journal|author1=Bahadorreza Ofoghi |author2=John Zeleznikow |author3=Clare MacMahon |author4=Markus Raab |title=Data mining in elite sports: A review and a framework |year=2013 |journal=Measurement in Physical Education and Exercise Science | volume=17 | issue=3 |url=http://www.tandfonline.com/doi/abs/10.1080/1091367X.2013.805137#.VI-ipE103Dc |doi=10.1080/1091367X.2013.805137 |pages=171–186}}&lt;/ref&gt;&lt;ref&gt;{{cite journal|author1=Iztok Fister Jr. |author2=Karin Ljubič |author3=Ponnuthrai Nagaratnam Suganthan |author4=Matjaž Perc |author5=Iztok Fister |title=Computational intelligence in sports: Challenges and opportunities within a new research domain |year=2015 |journal=Applied Mathematics and Computation | volume=262 |url=http://www.sciencedirect.com/science/article/pii/S0096300315004300 |doi=10.1016/j.amc.2015.04.004 |pages=178–186}}&lt;/ref&gt;

As another result of this development, the term 'computer science in sport' has been added in the encyclopedia of sports science in 2004.

== Areas of research ==
The importance and strong influence of computer science as an interdisciplinary partner for sport and sport science is mainly proven by the research activities in computer science in sport. The following IT concepts are thereby of particular interest:

* [[Data acquisition]] and [[data processing]]
* Databases and [[expert system]]s
* Modelling (mathematical, IT based, biomechanical, physiological)
* Simulation (interactive, animation etc.)
* Presentation

Based on the fields from above, the main areas of research in computer science in sport include amongst others:

* [[Training]] and coaching
* [[Biomechanics]]
* [[Sports equipment]] and technology
* Computer-aided applications (software, hardware) in sports
* [[Ubiquitous computing]] in sports
* [[Multimedia]] and [[Internet]]
* Documentation
* Education

== Research communities ==
A clear demonstration for the evolution and propagation towards computer science in sport is also the fact that nowadays people do research in this area all over the world. Since the 1990s many new national and international organizations regarding the topic of computer science in sport were established. These associations are regularly organizing congresses and workshops with the aim of dissemination as well as exchange of scientific knowledge and information on all sort of topics regarding the interdisciplinary discipline.

=== Historical survey ===
As a first example, in [[Australia]] and [[New Zealand]] scientists have built up the MathSport group of [[ANZIAM]] (Australia and New Zealand Industrial and Applied Mathematics), which since 1992 organizes biennial meetings, initially under the name &quot;Mathematics and Computers in Sport Conferences&quot;, and now &quot;[[MathSport]]&quot;.&lt;ref&gt;[http://www.anziam.org.au/MathSport MathSport], www.anziam.org.au&lt;/ref&gt; Main topics are mathematical models and computer applications in sports, as well as coaching and teaching methods based on informatics.

The European community was also among the leading motors of the emergence of the field. Some workshops on this topic were successfully organized in Germany since the late 1980s. In 1997 the first international meeting on computer science in sport was held in Cologne. The main aim was to spread out and share applications, ideas and concepts of the use of computers in sports, which should also make a contribution to the creation of internationalization and thus to boost research work in this area.

Since then, such international symposia took place every two years all over Europe. As the first conferences were a raving success, it was decided to go even further and the foundation of an organization was the logical consequence. This step was accomplished in 2003, when the International Association of Computer Science in Sport (IACSS) was established during the 4th international symposium in Barcelona, when Prof. Jürgen Perl was also chosen as the first president. A few years earlier, the first international e-journal on this topic (International Journal of Computer Science in Sport) was released already. The internationalization is confirmed moreover by the fact that three conferences already took place outside of Europe - in [[Calgary]] ([[Canada]]) in 2007, [[Canberra]] ([[Australia]]) in 2009 and [[Shanghai]] ([[China]]) in 2011. During the symposium in Calgary additionally the president position changed - it has been assigned to Prof. Arnold Baca, who has been re-elected in 2009 and 2011. The following Symposia on Computer Science in Sport took place in Europe again, in [[Istanbul]] ([[Turkey]]) in 2013 and in [[Loughborough]] ([[UK]]) in 2015. During the conference in Istanbul Prof. Martin Lames was elected as president of the IACSS and was re-elected in 2015.

=== National organizations ===
In addition to the international associations from above, currently the following national associations on computer science in sport exist (if available, the web addresses are also given):

* Austrian Association of Computer Science in Sport - http://www.sportinformatik.at
* British Association of Computer Science in Sport and Exercise
* Chinese Association of Computer Science in Sport
* Croatian Association of Computer Science in Sport
* Section Computer Science in Sport of the German Association of Sport Science - http://www.dvs-sportinformatik.de (in German)
* Indian Federation of Computer Science in Sport - http://www.ifcss.in
* Portuguese Association of Computer Science in Sport
* Turkish Association of Computer Science in Sport - http://www.tacss.com/

== References ==
{{reflist|2}}

== Further reading ==
* Dabnichki P. &amp; Baca, A. (2008). Computers in Sport, WIT Press. ISBN 978-1-84564-064-4
* Baca, A. (2015). Computer Science in Sport - Research and practice, Routledge. ISBN 978-1-315-88178-2

== External links ==
* [http://www.anziam.org.au/MathSport/ MathSport - ANZIAM (Australia and New Zealand Industrial and Applied Mathematics)]
* [https://web.archive.org/web/20090803130839/http://www.ecss.de:80/ ECSS (European College of Sport Science)]
* [http://www.sportsengineering.co.uk ISEA (International Sports Engineering Association)]
* [http://www.iacss.org IACSS (International Association of Computer Science in Sport)]

{{DEFAULTSORT:Computer Science In Sport}}
[[Category:Computer science|Sport]]
[[Category:Sports science]]</text>
      <sha1>26s002bfxi3fa4gk7s6lsz0esk5lvw5</sha1>
    </revision>
  </page>
  <page>
    <title>Trace Cache</title>
    <ns>0</ns>
    <id>51997537</id>
    <revision>
      <id>757025780</id>
      <parentid>756324920</parentid>
      <timestamp>2016-12-28T09:09:09Z</timestamp>
      <contributor>
        <username>DrStrauss</username>
        <id>29858946</id>
      </contributor>
      <comment>added [[Category:Computer science]]; removed {{uncategorized}} using [[WP:HC|HotCat]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8531">[[File:TraceCache.png|thumb|Working of a trace Cache|456x456px]]{{DISPLAYTITLE:Trace Cache}}
'''Trace Cache''' (also known as ''execution trace cache'') is a very specialized [[Cache (computing)|cache]] which stores the dynamic stream of [[Instruction (computer science)|instructions]] known as ''trace''. It helps in increasing the instruction fetch bandwidth and decreasing power consumption (in the case of [[Intel]] [[Pentium 4]] ) by storing traces of [[Instruction (computer science)|instructions]] that have already been fetched and decoded.&lt;ref name=&quot;:0&quot; /&gt; Trace Processor&lt;ref&gt;Eric Rotenberg, Quinn Jacobson, Yiannakis Sazeides, and James E. Smith. [http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.150.3091&amp;rank=1&amp;q=trace%20processor&amp;osm=&amp;ossid= Trace Processors]. Proceedings of the''30th IEEE/ACM International Symposium on Microarchitecture (MICRO-30)'', pp. 138-148, December 1997&lt;/ref&gt; is an architecture designed around the Trace Cache and processes the instructions at trace level granularity.

__TOC__

== Background ==
The earliest academic publication of trace cache was ''&quot;Trace Cache: a Low Latency Approach to High Bandwidth Instruction Fetching&quot;''.&lt;ref name=&quot;:0&quot;&gt;{{Cite journal|last=Rotenberg|first=Eric|last2=Bennett|first2=Steve|last3=Smith|first3=James E.|last4=Rotenberg|first4=Eric|date=1996-01-01|title=Trace Cache: a Low Latency Approach to High Bandwidth Instruction Fetching|url=http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.140.2177|journal=In Proceedings of the 29th International Symposium on Microarchitecture|pages=24–34}}&lt;/ref&gt;   This widely acknowledged paper was presented by Eric Rotenberg, Steve Bennett, and Jim Smith at 1996 [[International Symposium on Microarchitecture|MICRO]] conference. An earlier publication is (US patent 5381533),&lt;ref&gt;{{Citation|last=Peleg|first=Alexander|title=Dynamic flow instruction cache memory organized around trace segments independent of virtual address line|date=Jan 10, 1995|url=http://www.google.com/patents/US5381533|last2=Weiser|first2=Uri|accessdate=2016-10-18}}&lt;/ref&gt; by Alex Peleg and Uri Weiser of Intel Corp., &quot;''Dynamic flow instruction cache memory organized around trace segments independent of virtual address line''&quot;, a continuation of an application filed in 1992, later abandoned.

== Necessity  ==
Wider [[superscalar processor]]s demand multiple instructions to be fetched in a single cycle for higher performance. Instructions to be fetched are not always in contiguous memory locations ([[basic block]]s) because of [[Branch instruction|branch]] and [[Jump instruction|jump]] instructions. So processors need additional logic and hardware support to fetch and align such instructions from non-contiguous basic blocks.  If multiple branches are predicted  as ''not-taken'', then processors can fetch instructions from multiple contiguous basic blocks in a single cycle. However, if any of the branches is predicted as ''taken'', then processor should fetch instructions from the taken path in that same cycle. This limits the fetch capability of a processor.
[[File:BasicBlocks.png|thumb|Basic Blocks of a simple if-else loop|240x240px]]
Consider these four basic blocks (A, B, C, D) as shown in the figure that correspond to a simple if-else loop. These blocks will be stored contiguously as ABCD in the memory. If the branch D is predicted ''not-taken,'' the fetch unit can fetch the basic blocks A,B,C which are placed contiguously. However, if D is predicted ''taken'', the fetch unit has to fetch  A,B,D  which are non-contiguously placed. Hence, fetching these blocks which are non contiguously places, in a single cycle will be very difficult. So, in situations like these trace cache comes in aid to the processor.

Once fetched, trace cache stores the instructions in their dynamic sequence. When these instructions are encountered again, trace cache allows the instruction fetch unit of a processor to fetch several basic blocks from it without having to worry about branches in the execution flow. Instructions will be stored in trace cache either after they have been decoded, or as they are retired. However, instruction sequence is speculative if they are stored just after decode stage.

== Trace Structure ==

Trace, also called as dynamic instruction sequence, is an entry in the trace cache. It can be characterized by ''maximum no of instructions'' and  ''maximum basic blocks''. Traces can start at any dynamic instruction. Multiple traces can have same starting instruction i.e. same starting [[Program counter|PC]](Program Counter) and instructions from different basic blocks as per the branch outcomes. For the figure above,  ABC and ABD are valid traces. They both start at the same [[Program counter|PC]] (address of A) and have different basic blocks as per D's prediction.

Traces usually terminates when one of the following occurs:
# Trace got filled with allowable ''maximum no of instructions'' 
# Trace has allowable maximum basic blocks
# Return Instructions
# Indirect branches
# System calls

=== Trace Control Information ===
A single trace will have following information.
* Starting [[Program counter|PC]] - [[Program counter|PC]] of the first instruction in trace  
* Branch Flag - ( ''maximum basic blocks -1'') branch predictions
* Branch Mask - no of branches in the trace and whether trace ends in a branch or not
* Trace Fall through - Next [[Program counter|PC]] if last instruction is ''not-taken'' branch or not a branch
* Trace Target - Address of last branch's taken target

== Trace Cache Design ==
Following are the factors that need to be considered while designing a trace cache.
* Trace Selection Policies -  ''maximum no of instructions'' and  ''maximum basic blocks in a trace''
* [[Cache associativity|Associativity]] - no of ways a cache can have 
* Cache Indexing Method - Concatenation or XOR with [[Program counter|PC]] bits
* Path Associativity - traces with same starting [[Program counter|PC]] but with different basic blocks can be mapped to different sets  
* Trace Cache Fill choices -
*# After decode stage (Speculative)
*# After retire stage
A trace cache is not on the critical path of instruction fetch&lt;ref name=&quot;:1&quot;&gt;Leon Gu; Dipti Motiani (October 2003). [http://www.cs.cmu.edu/afs/cs/academic/class/15740-f03/www/lectures/TraceCache_slides.pdf &quot;Trace Cache&quot;] (PDF). Retrieved2013-10-06.
&lt;/ref&gt;

== Hit/Miss Logic ==

Trace lines are stored in the trace cache based on the [[program counter]] of the first instruction in the trace and a set of branch predictions. This allows for storing different trace paths that start on the same address, each representing different branch outcomes. This method of tagging helps to provide path associativity to the trace cache. Other method can include having only starting [[Program counter|PC]] as tag in trace cache. In the instruction fetch stage of a [[Instruction pipeline|pipeline]], the current [[program counter]] along with a set of branch predictions is checked in the trace cache for a [[Cache hit|hit]]. If there is a hit, a trace line is supplied to fetch unit which does not have to go to a regular cache or to memory for these instructions. The trace cache continues to feed the fetch unit until the trace line ends or until there is a [[misprediction]] in the pipeline. If there is a miss, a new trace starts to be built.

The Pentium 4's trace cache stores [[micro-operations]] resulting from decoding [[X86 instruction listings|x86 instructions]], providing also the functionality of a micro-operation cache. Having this, the next time an instruction is needed, it does not have to be decoded into micro-ops again.&lt;ref&gt;Agner Fog (2014-02-19). [http://www.agner.org/optimize/microarchitecture.pdf &quot;The microarchitecture of Intel, AMD and VIA CPUs: An optimization guide for assembly programmers and compiler makers&quot;] (PDF). ''agner.org''. Retrieved 2014-03-21.&lt;/ref&gt;

== Disadvantages ==
The disadvantages of trace cache are:
# Redundant instruction storage between trace cache and instruction cache and within trace cache itself.&lt;ref&gt;{{Cite web|url=http://webcache.googleusercontent.com/search?q=cache:gljZlApiEfsJ:www.cs.virginia.edu/~mc2zk/cs451/mco_tc.ppt+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=us|title=Trace Cache|last=Co|first=Michele|date=|website=|publisher=www.cs.virginia.edu|access-date=2016-10-21}}&lt;/ref&gt; 
# Power inefficiency and hardware complexity&lt;ref name=&quot;:1&quot; /&gt;

== See also ==
* [[CPU cache]]
* [[Instruction cycle]]

== References ==
&lt;references /&gt;



[[Category:Computer science]]</text>
      <sha1>l86svcbf7xljmn8pae6rdkwkektuk6b</sha1>
    </revision>
  </page>
  <page>
    <title>Wiener connector</title>
    <ns>0</ns>
    <id>45655492</id>
    <revision>
      <id>759706479</id>
      <parentid>725381093</parentid>
      <timestamp>2017-01-12T18:57:49Z</timestamp>
      <contributor>
        <ip>68.181.207.217</ip>
      </contributor>
      <comment>added link to references and added categories</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8842">{{Orphan|date=February 2016}}

In mathematics applied to the study of networks, the '''Wiener connector''', named in honor of chemist [[Harry Wiener]] who first introduced the [[Wiener Index]], is a means of maximizing efficiency in connecting specified &quot;query vertices&quot; in a network. Given a [[connected graph|connected]], [[undirected graph]] and a set of query vertices in a graph, the '''minimum Wiener connector''' is an [[induced subgraph]] that connects the query vertices and minimizes the sum of [[shortest path]] distances among all pairs of vertices in the subgraph. In [[combinatorial optimization]], the '''minimum Wiener connector problem''' is the problem of finding the minimum Wiener connector. It can be thought of as a version of the classic [[Steiner tree problem]] (one of [[Karp's 21 NP-complete problems]]), where instead of minimizing the size of the tree, the objective is to minimize the distances in the subgraph.&lt;ref name=&quot;steiner&quot;&gt;{{cite journal|last1=Hwang|first1=Frank|last2=Richards|first2=Dana|last3=Winter|first3=Dana|last4=Winter|first4=Pawel|title=The Steiner Tree Problem|journal=Annals of Discrete Mathematics|date=1992|url=http://www.sciencedirect.com/science/bookseries/01675060/53}}&lt;/ref&gt;&lt;ref name=&quot;dimacs&quot;&gt;[http://dimacs11.cs.princeton.edu/ DIMACS Steiner Tree Challenge]&lt;/ref&gt;

The minimum Wiener connector was first presented by Ruchansky, et al. in 2015.&lt;ref name=&quot;sigmod&quot;&gt;{{cite journal|last2=Bonchi|first2=Francesco|last3=Garcia-Soriano|first3=David|last4=Gullo|first4=Francesco|last5=Kourtellis|first5=Nicolas|date=2015|year=|title=The Minimum Wiener Connector|url=https://arxiv.org/abs/1504.00513|journal=SIGMOD|volume=|pages=|via=|last1=Ruchansky|first1=Natali}}&lt;/ref&gt;

The minimum Wiener connector has applications in many domains where there is a graph structure and an interest in learning about connections between sets of individuals. For example, given a set of patients infected with a viral disease, which other patients should be checked to find the culprit? Or given a set of proteins of interest, which other proteins participate in pathways with them?

==Problem definition==
The [[Wiener index]] is the sum of shortest path distances in a (sub)graph. Using &lt;math&gt;d(u,v)&lt;/math&gt; to denote the shortest path between &lt;math&gt;u&lt;/math&gt; and &lt;math&gt;v&lt;/math&gt;, the Wiener index of a (sub)graph &lt;math&gt;S&lt;/math&gt;, denoted &lt;math&gt;W(S)&lt;/math&gt;, is defined as
: &lt;math&gt;W(S) = \sum_{(u, v) \in S} d(u,v)&lt;/math&gt;.

The minimum Wiener connector problem is defined as follows. Given an undirected and unweighted graph with vertex set &lt;math&gt;V&lt;/math&gt; and edge set &lt;math&gt;E&lt;/math&gt; and a set of query vertices &lt;math&gt;Q\subseteq V&lt;/math&gt;, find a connector &lt;math&gt;H\subseteq V&lt;/math&gt; of minimum Wiener index. More formally, the problem is to compute
: &lt;math&gt;\operatorname*{arg\,min}_H W(H\cup Q)&lt;/math&gt;,
that is, find a connector &lt;math&gt;H&lt;/math&gt; that minimizes the sum of shortest paths in &lt;math&gt;H&lt;/math&gt;.

==Relationship to Steiner tree==
[[File:SteinerExample nicer.pdf|thumb|upright=2.0|The optimal solutions to the Steiner tree problem and the minimum Wiener connector can differ. Define the set of query vertices ''Q'' by ''Q'' = {''v''&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, ''v''&lt;sub&gt;10&lt;/sub&gt;}. The unique optimal solution to the Steiner tree problem is ''Q'' itself, which has Wiener index 165, whereas the optimal solution for the minimum Wiener connector problem is ''Q'' ∪ {''r''&lt;sub&gt;1&lt;/sub&gt;, ''r''&lt;sub&gt;2&lt;/sub&gt;}, which has Wiener index 142.]]
The minimum Wiener connector problem is related to the [[Steiner tree problem]]. In the former, the [[objective function]] in the minimization is the Wiener index of the connector, whereas in the latter, the objective function is the sum of the weights of the edges in the connector. The optimum solutions to these problems may differ, given the same graph and set of query vertices. In fact, a solution for the Steiner tree problem may be arbitrarily bad for the minimum Wiener connector problem; the graph on the right provides an example.

== Computational complexity ==

===Hardness===
The problem is [[NP-hard]], and does not admit a [[polynomial-time approximation scheme]] unless [[P = NP|'''P''' = '''NP''']].&lt;ref name=&quot;sigmod&quot;/&gt; This can be proven using the [[inapproximability]] of [[vertex cover]] in bounded degree graphs.&lt;ref name=&quot;dinursafra&quot;&gt;{{cite journal|last1=Dinur|first1=Irit|last2=Safra|first2=Samuel|title=On the hardness of approximating minimum vertex cover|journal=Annals of Mathematics|date=2005}}&lt;/ref&gt; Although there is no polynomial-time approximation scheme, there is a polynomial-time constant-factor approximation—an algorithm that finds a connector whose Wiener index is within a constant multiplicative factor of the Wiener index of the optimum connector. In terms of [[complexity class]]es, the minimum Wiener connector problem is in '''[[APX]]''' but is not in '''PTAS''' unless '''P''' = '''NP'''.

=== Exact algorithms ===
An exhaustive search over all possible subsets of vertices to find the one that induces the connector of minimum Wiener index yields an algorithm that finds the optimum solution in &lt;math&gt;2^{O(n)}&lt;/math&gt; time (that is, [[exponential time]]) on graphs with ''n'' vertices. In the special case that there are exactly two query vertices, the optimum solution is the [[shortest path]] joining the two vertices, so the problem can be solved in [[polynomial time]] by computing the shortest path. In fact, for any fixed constant number of query vertices, an optimum solution can be found in polynomial time.

=== Approximation algorithms ===
There is a constant-factor approximation algorithm for the minimum Wiener connector problem that runs in time &lt;math&gt;O(q (m \log n + n \log^2 n))&lt;/math&gt; on a graph with ''n'' vertices, ''m'' edges, and ''q'' query vertices, roughly the same time it takes to compute shortest-path distances from the query vertices to every other vertex in the graph.&lt;ref name=&quot;sigmod&quot;/&gt; The central approach of this algorithm is to reduce the problem to the vertex-weighted Steiner tree problem, which admits a constant-factor approximation in particular instances related to the minimum Wiener connector problem.

==Behavior==

The minimum Wiener connector behaves like [[Centrality#Betweenness centrality|betweenness centrality]].

When the query vertices belong to the same community, the non-query vertices that form the minimum Wiener connector tend to belong to the same community and have high centrality within the community.  Such vertices are likely to be [[influential]] vertices playing leadership roles in the community. In a [[social network]], these influential vertices might be good users for spreading information or to target in a viral marketing campaign.&lt;ref name=&quot;viral&quot;&gt;{{cite journal | first1=Oliver | last1=Hinz | first2=Bernd | last2=Skiera | first3=Christian | last3=Barrot | first4=Jan U. | last4=Becker | title=Seeding Strategies for Viral Marketing: An Empirical Comparison | journal=Journal of Marketing | volume=75 | number=6 | pages=55–71 | year = 2011 | doi=10.1509/jm.10.0088}}&lt;/ref&gt;

When the query vertices belong to different communities, the non-query vertices that form the minimum Wiener connector contain vertices adjacent to edges that bridge the different communities. These vertices span a [[Social Network#Structural holes|structural hole]] in the graph and are important.&lt;ref name=&quot;structhole&quot;&gt;{{cite conference|last1=Lou|first1=Tiancheng|last2=Tang|first2=Jie|title=Mining Structural Hole Spanners Through Information Diffusion in Social Networks|booktitle=Proceedings of the 22nd International Conference on World Wide Web|date=2013|isbn=9781450320351|location=Rio de Janeiro, Brazil|pages=825–836|url=http://dl.acm.org/citation.cfm?id=2488388.2488461|publisher=International World Wide Web Conferences Steering Committee}}&lt;/ref&gt;

==Applications==
The minimum Wiener connector is useful in applications in which one wishes to learn about the relationship between a set of vertices in a graph. For example,
* in [[biology]], it provides insight into how a set of proteins in a [[protein–protein interaction]] network are related,
* in [[social network]]s (like [[Twitter]]), it demonstrates the communities to which a set of users belong and how these communities are related,
* in [[computer network]]s, it may be useful in identifying an efficient way to route a [[multicast]] message to a set of destinations.

==References==
{{reflist}}

[[Category:NP-complete problems]]
[[Category:Trees (graph theory)]]
[[Category:Computational problems in graph theory]]
[[Category:Geometric algorithms]]
[[Category:Geometric graphs]]
[[Category:Graph algorithms]]
[[Category:Data mining]]
[[Category:Social networks]]
[[Category:Computational biology]]
[[Category:Computer science]]
[[Category:Algorithms]]
[[Category:Information retrieval]]
__INDEX__</text>
      <sha1>bvbcr40ojals22bj58wcu20m3tvdne4</sha1>
    </revision>
  </page>
  <page>
    <title>Instance selection</title>
    <ns>0</ns>
    <id>53279262</id>
    <revision>
      <id>768324938</id>
      <parentid>767218610</parentid>
      <timestamp>2017-03-03T03:31:13Z</timestamp>
      <contributor>
        <username>Gjs238</username>
        <id>486612</id>
      </contributor>
      <comment>removed [[Category:Data science]] using [[WP:HC|HotCat]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4492">{{New unreviewed article|date=February 2017}}

'''Instance selection''' &lt;ref name=GARCIA_2015&gt;S. García, J. Luengo, and F. Herrera, Data preprocessing in data mining. Springer, 2015.&lt;/ref&gt; (or dataset reduction, or dataset condensation) is an important [[Data pre-processing]] step that can be applied in many [[Machine learning]] (or [[Data mining]]) tasks. Approaches for instance selection can be applied for reducing the original dataset to a manageable volume, leading to a reduction of the computational resources that are necessary for performing the learning process. Algorithms of instance selection can also be applied for removing noisy instances, before applying learning algorithms. This step can improve the accuracy in classification problems.

Algorithm for instance selection should identify a subset of the total available data to achieve the original purpose of the data mining (or machine learning) application as if the whole data had been used. Considering this, the optimal outcome of IS would be the minimum data subset that can accomplish the same task with no performance loss, in comparison with the performance achieved when the task is performed using the whole available data. Therefore, every instance selection strategy should deal with a trade-off between the reduction rate of the dataset and the classification quality.

== Instance selection algorithms ==

The literature provides several differente algorithms for instance selection. They can be distinguished from each other according to several different criteria. Considering this, instance selection algorithms can be grouped in two main classes, according to what instances they select: algorithms that preserve the instances at the boundaries of classes and algorithms that preserve the internal instances of the classes. Within the category of algorithms that select instances at the boundaries it is possible to cite DROP3,&lt;ref name=DROP_2000&gt;D. R. Wilson and T. R. Martinez, Reduction techniques for instance-based learning algorithms, Machine learning,vol. 38, no. 3, pp. 257–286, 2000.&lt;/ref&gt; ICF &lt;ref name=ICF_2002&gt;H. Brighton and C. Mellish, Advances in instance selection for instance-based learning algorithms, Data mining and knowledge discovery, vol. 6, no. 2, pp. 153–172, 2002.&lt;/ref&gt; and LSBo.&lt;ref name=LSBo_LSSm_2015&gt;E. Leyva, A. González, and R. Pérez, Three new instance selection methods based on local sets: A comparative study with several approaches from a bi-objective perspective, Pattern Recognition, vol. 48, no. 4, pp. 1523–1537, 2015.&lt;/ref&gt; On the other hand, within the category of algorithms that select internal instances it is possible to mention ENN &lt;ref name=ENN_1972&gt;D. L. Wilson, “Asymptotic properties of nearest neighbor rules using edited data,” Systems, Man and Cybernetics, IEEE Transactions on, no. 3, pp. 408–421, 1972.&lt;/ref&gt; and LSSm.&lt;ref name=LSBo_LSSm_2015 /&gt; In general, algorithm such as ENN and LSSm are used for removing harmful (noisy) instances from the dataset. They do not reduce the data as the algorithms that select border instances, but they remove instances at the boundaries that have negative impact in the data ming task. They can be used bay other instance selection algorithms, as a filtering step. For example, the ENN algorithm is used by DROP3 as the first step, and the LSSm algorithm is used by LSBo.

There is also another group os algorithms that adopt different selection criteria. For example, the algorithms LDIS &lt;ref name=LDIS_2015&gt;Carbonera, Joel Luis, and Mara Abel. A density-based approach for instance selection. IEEE 27th International Conference on Tools with Artificial Intelligence (ICTAI), 2015.&lt;/ref&gt; and CDIS &lt;ref name=CDIS_2016&gt;Carbonera, Joel Luis, and Mara Abel. A novel density-based approach for instance selection. IEEE 28th International Conference on Tools with Artificial Intelligence (ICTAI), 2016.&lt;/ref&gt; select the densest instances in a given arbitrary neighborhood. The selected instances can include both, border and internal instances. The LDIS and CDIS algorithms are very simple and select subsets that are very representative of the original dataset. Besides that, since they search by the representative instances in each class separately, they are faster (in terms of time complexity and effective running time) than other algorithms, such as DROP3 and ICF.

==References==
{{reflist}}

*
*
*
*

[[Category:Machine learning]]
[[Category:Data mining]]
[[Category:Computer science]]</text>
      <sha1>3091k7p2vi71wg2s6cteii380h5jz2v</sha1>
    </revision>
  </page>
  <page>
    <title>Viola–Jones object detection framework</title>
    <ns>0</ns>
    <id>14669989</id>
    <revision>
      <id>768000189</id>
      <parentid>768000047</parentid>
      <timestamp>2017-03-01T05:04:06Z</timestamp>
      <contributor>
        <username>Chinmayee Mishra</username>
        <id>27111003</id>
      </contributor>
      <comment>added [[Category:Computer science]] using [[WP:HC|HotCat]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="16208">{{cleanup rewrite|date=February 2015}}
The '''Viola–Jones object detection framework''' is the first [[object detection]] framework to provide competitive object detection rates in real-time proposed in 2001 by [[Paul Viola]] and Michael Jones.&lt;ref&gt;[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.10.6807 Rapid object detection using a boosted cascade of simple features]&lt;/ref&gt;&lt;ref&gt;[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.110.4868 Viola, Jones: Robust Real-time Object Detection, IJCV 2001] See pages 1,3.&lt;/ref&gt; Although it can be trained to detect a variety of object classes, it was motivated primarily by the problem of [[face detection]]. This algorithm is implemented in [[OpenCV]] as &lt;code&gt;cvHaarDetectObjects()&lt;/code&gt;.

== Problem description ==

The problem to be solved is detection of faces in an image. A human can do this easily, but a computer needs precise instructions and constraints.  To make the task more manageable, Viola–Jones requires full view frontal upright faces. Thus in order to be detected, the entire face must point towards the camera and should not be tilted to either side. While it seems these constraints could diminish the algorithm's utility somewhat, because the detection step is most often followed by a recognition step, in practice these limits on pose are quite acceptable.

== Components of the framework ==
[[Image:Prm VJ fig1 featureTypesWithAlpha.png|thumb|right|Feature types used by Viola and Jones]]

=== Feature types and evaluation ===
The characteristics of Viola–Jones algorithm which make it a good detection algorithm are:
* Robust – very high detection rate (true-positive rate) &amp; very low false-positive rate always.
* Real time – For practical applications at least 2 frames per second must be processed.
* Face detection only (not recognition) - The goal is to distinguish faces from non-faces (detection is the first step in the recognition process).

The algorithm has four stages:
# Haar Feature Selection
# Creating an Integral Image
# Adaboost Training
# Cascading Classifiers

The features sought by the detection framework universally involve the sums of image pixels within rectangular areas. As such, they bear some resemblance to [[Haar-like features|Haar basis functions]], which have been used previously in the realm of image-based object detection.&lt;ref&gt;C. Papageorgiou, M. Oren and T. Poggio. A General Framework for Object Detection. ''International Conference on Computer Vision'', 1998&lt;/ref&gt; However, since the features used by Viola and Jones all rely on more than one rectangular area, they are generally more complex. The figure on the right illustrates the four different types of features used in the framework. The value of any given feature is the sum of the pixels within clear rectangles subtracted from the sum of the pixels within shaded rectangles. Rectangular features of this sort are primitive when compared to alternatives such as [[steerable filter]]s. Although they are sensitive to vertical and horizontal features, their feedback is considerably coarser.

[[File:Haar Feature that looks similar to the bridge of the nose is applied onto the face.jpg|thumb|left|Haar Feature that looks similar to the bridge of the nose is applied onto the face]]
[[File:Haar Feature that looks similar to the eye region which is darker than the upper cheeks is applied onto a face.jpg|thumb|left|Haar Feature that looks similar to the eye region which is darker than the upper cheeks is applied onto a face]]
[[File:3rd and 4th kind of Haar Feature.jpg|thumb|left|3rd and 4th kind of Haar Feature]]

1. Haar Features – All human faces share some similar properties. These regularities may be matched using '''Haar Features'''.

A few properties common to human faces:
* The eye region is darker than the upper-cheeks.
* The nose bridge region is brighter than the eyes.

Composition of properties forming matchable facial features:
* Location and size: eyes, mouth, bridge of nose
* Value: oriented gradients of pixel intensities

The four features matched by this algorithm are then sought in the image of a face (shown at left).

Rectangle features:
* Value = Σ (pixels in black area) - Σ (pixels in white area)
* Three types: two-, three-, four-rectangles, Viola &amp; Jones used two-rectangle features
* For example: the difference in brightness between the white &amp;black rectangles over a specific area
* Each feature is related to a special location in the sub-window

2. An image representation called the [[summed area table|integral image]] evaluates rectangular features in ''constant'' time, which gives them a considerable speed advantage over more sophisticated alternative features. Because each feature's rectangular area is always adjacent to at least one other rectangle, it follows that any two-rectangle feature can be computed in six array references, any three-rectangle feature in eight, and any four-rectangle feature in nine.

The integral image at location (x,y), is the sum of the pixels above and to the left of (x,y), inclusive.

=== Learning algorithm ===

The speed with which features may be evaluated does not adequately compensate for their number, however. For example, in a standard 24x24 pixel sub-window, there are a total of &lt;math&gt;M = 162,336&lt;/math&gt;&lt;ref&gt;[https://stackoverflow.com/questions/1707620/viola-jones-face-detection-claims-180k-features Viola-Jones’ face detection claims 180k features]&lt;/ref&gt; possible features, and it would be prohibitively expensive to evaluate them all when testing an image. Thus, the object detection framework employs a variant of the learning algorithm [[AdaBoost]] to both select the best features and to train classifiers that use them. This algorithm constructs a “strong” classifier as a linear combination of weighted simple “weak” classifiers.

&lt;math&gt;h(\mathbf{x}) = \text{sign}\left(\sum_{j=1}^{M} \alpha_j h_j(\mathbf{x})\right)&lt;/math&gt;

Each weak classifier is a threshold function based on the feature &lt;math&gt;f_j&lt;/math&gt;.

&lt;math&gt;h_j(\mathbf{x}) = 
\begin{cases}
-s_j &amp;\text{if } f_j &lt; \theta_j\\
s_j &amp;\text{otherwise}
\end{cases}&lt;/math&gt;

The threshold value &lt;math&gt;\theta_j&lt;/math&gt; and the polarity &lt;math&gt;s_j \in \pm 1&lt;/math&gt; are determined in the training, as well as the coefficients &lt;math&gt;\alpha_j&lt;/math&gt;.

Here a simplified version of the learning algorithm is reported:&lt;ref&gt;R. Szeliski, ''Computer Vision, algorithms and applications'', Springer&lt;/ref&gt;

'''Input:''' Set of &lt;math&gt;N&lt;/math&gt; positive and negative training images with their labels &lt;math&gt;{(\mathbf{x}^i,y^i)}&lt;/math&gt;. If image &lt;math&gt;i&lt;/math&gt; is a face &lt;math&gt;y^i=1&lt;/math&gt;, if not &lt;math&gt;y^i=-1&lt;/math&gt;.
# Initialization: assign a weight &lt;math&gt;w^i_{1}=\frac{1}{N}&lt;/math&gt; to each image &lt;math&gt;i&lt;/math&gt;.
# For each feature &lt;math&gt;f_j&lt;/math&gt; with &lt;math&gt;j = 1,...,M&lt;/math&gt;
## Renormalize the weights such that they sum to one.
## Apply the feature to each image in the training set, then find the optimal threshold and polarity &lt;math&gt;\theta_j,s_j&lt;/math&gt; that minimizes the weighted classification error. That is &lt;math&gt;\theta_j,s_j = \arg\min_{\theta,s} \;\sum_{i=1}^N w^i_{j} \varepsilon^i_{j}&lt;/math&gt; where &lt;math&gt;\varepsilon^i_{j} = 
\begin{cases}
0 &amp;\text{if }y^i = h_j(\mathbf{x}^i,\theta_j,s_j)\\
1 &amp;\text{otherwise}
\end{cases}
&lt;/math&gt;
## Assign a weight &lt;math&gt;\alpha_j&lt;/math&gt; to &lt;math&gt;h_j&lt;/math&gt; that is inversely proportional to the error rate. In this way best classifiers are considered more.
## The weights for the next iteration, i.e. &lt;math&gt;w_{j+1}^i&lt;/math&gt;, are reduced for the images &lt;math&gt;i&lt;/math&gt; that were correctly classified.
# Set the final classifier to &lt;math&gt;h(\mathbf{x}) = \text{sign}\left(\sum_{j=1}^{M} \alpha_j h_j(\mathbf{x})\right)&lt;/math&gt;

=== Cascade architecture ===

* On average only 0.01% of all sub-windows are positive (faces)
* Equal computation time is spent on all sub-windows
* Must spend most time only on potentially positive sub-windows.
* A simple 2-feature classifier can achieve almost 100% detection rate with 50% FP rate.
* That classifier can act as a 1st layer of a series to filter out most negative windows
* 2nd layer with 10 features can tackle “harder” negative-windows which survived the 1st layer, and so on…
* A cascade of gradually more complex classifiers achieves even better detection rates. The evaluation of the strong classifiers generated by the learning process can be done quickly, but it isn’t fast enough to run in real-time. For this reason, the strong classifiers are arranged in a cascade in order of complexity, where each successive classifier is trained only on those selected samples which pass through the preceding classifiers. If at any stage in the cascade a classifier rejects the sub-window under inspection, no further processing is performed and continue on searching the next sub-window. The cascade therefore has the form of a degenerate tree. In the case of faces, the first classifier in the cascade – called the attentional operator – uses only two features to achieve a false negative rate of approximately 0% and a false positive rate of 40%.&lt;ref&gt;[http://research.microsoft.com/~viola/Pubs/Detect/violaJones_IJCV.pdf Viola, Jones: Robust Real-time Object Detection, IJCV 2001] See page 11.&lt;/ref&gt; The effect of this single classifier is to reduce by roughly half the number of times the entire cascade is evaluated.

In cascading, each stage consists of a strong classifier. So all the features are grouped into several stages where each stage has certain number of features.

The job of each stage is to determine whether a given sub-window is definitely not a face or may be a face. A given sub-window is immediately discarded as not a face if it fails in any of the stages.

A simple framework for cascade training is given below:

* User selects values for f, the maximum acceptable false positive rate per layer and d, the minimum acceptable detection rate per layer.
* User selects target overall false positive rate Ftarget.
* P = set of positive examples
* N = set of negative examples

 F(0) = 1.0; D(0) = 1.0; i = 0
 
 '''while''' F(i) &gt; Ftarget
     i++
     n(i) = 0; F(i)= F(i-1)
 
     '''while''' F(I) &gt; f x F(i-1)
       n(i) ++
       use P and N to train a classifier with n(I) features using [[AdaBoost]]
       Evaluate current cascaded classifier on validation set to determine F(i) &amp; D(i)
       '''decrease''' threshold for the ith classifier 
         '''until''' the current cascaded classifier has a detection rate of at least d x D(i-1) (this also affects F(i))
       N = ∅
       '''if''' F(i) &gt; Ftarget '''then''' 
         evaluate the current cascaded detector on the set of non-face images 
         and put any false detections into the set N.

The cascade architecture has interesting implications for the performance of the individual classifiers. Because the activation of each classifier depends entirely on the behavior of its predecessor, the false positive rate for an entire cascade is:

: &lt;math&gt;F = \prod_{i=1}^K f_i.&lt;/math&gt;

Similarly, the detection rate is:

: &lt;math&gt;D = \prod_{i=1}^K d_i.&lt;/math&gt;

Thus, to match the false positive rates typically achieved by other detectors, each classifier can get away with having surprisingly poor performance. For example, for a 32-stage cascade to achieve a false positive rate of &lt;math&gt;10^{-6}&lt;/math&gt;, each classifier need only achieve a false positive rate of about 65%. At the same time, however, each classifier needs to be exceptionally capable if it is to achieve adequate detection rates. For example, to achieve a detection rate of about 90%, each classifier in the aforementioned cascade needs to achieve a detection rate of approximately 99.7%. {{citation needed|date=October 2013}}

== Advantages of Viola–Jones algorithm ==

* Efficient feature selection
* Scale and location invariant detector
* Instead of scaling the image itself (e.g. pyramid-filters), we scale the features.
* Such a generic detection scheme can be trained for detection of other types of objects (e.g. cars, hands)

== Disadvantages of Viola–Jones algorithm ==

* Detector is most effective only on frontal images of faces
* It can hardly cope with 45° face rotation both around the vertical and horizontal axis.
* Sensitive to lighting conditions
* We might get multiple detections of the same face, due to overlapping sub-windows.

== MATLAB code for using the cascadeObjectDetector() function on pictures ==

&lt;source lang=&quot;matlab&quot;&gt;
function [ ] = Viola_Jones_img( Img )
%Viola_Jones_img( Img )
% Img - input image
% Example how to call function: Viola_Jones_img(imread('name_of_the_picture.jpg'))

faceDetector = vision.CascadeObjectDetector;
bboxes = step(faceDetector, Img);
figure, imshow(Img), title('Detected faces');hold on
for i=1:size(bboxes,1)
    rectangle('Position',bboxes(i,:),'LineWidth',2,'EdgeColor','y');
end
end
&lt;/source&gt;

== Related face detection and tracking algorithm ==

A method similar to Viola–Jones but that can better detect and track tilted and rotated faces is the [[Kanade–Lucas–Tomasi feature tracker|KLT algorithm]]. Here numerous feature points are acquired by first scanning the face. These points then may be detected and tracked even when the face is tilted or turned away from the camera, something Viola–Jones has difficulty doing due to its dependence on rectangles.&lt;ref&gt;[http://in.mathworks.com/help/vision/examples/face-detection-and-tracking-using-the-klt-algorithm.html Face Detection and Tracking using the KLT algorithm]&lt;/ref&gt;

== Improvements over the Viola–Jones algorithm ==

An improved algorithm on Viola–Jones object detector&lt;ref&gt;[http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6269796 An improved algorithm on Viola-Jones object detector]&lt;/ref&gt;

'''MATLAB implementation of Viola–Jones algorithm'''&lt;ref&gt;[http://in.mathworks.com/help/vision/ref/vision.cascadeobjectdetector-class.html MATLAB implementation of Viola–Jones algorithm]&lt;/ref&gt;

'''OpenCV implementation of Viola–Jones algorithm'''

Haar Cascade Detection in OpenCV&lt;ref&gt;[http://docs.opencv.org/trunk/doc/py_tutorials/py_objdetect/py_face_detection/py_face_detection.html OpenCV Implementation of Viola–Jones]&lt;/ref&gt;

Cascade Classifier Training in OpenCV&lt;ref&gt;[http://docs.opencv.org/doc/user_guide/ug_traincascade.html Cascade Classifier Training in OpenCV]&lt;/ref&gt;

'''Citations of the Viola–Jones algorithm in Google Scholar'''&lt;ref&gt;[https://scholar.google.com/citations?view_op=view_citation&amp;hl=en&amp;user=G2-nFaIAAAAJ&amp;citation_for_view=G2-nFaIAAAAJ:u5HHmVD_uO8C Citations of the Viola–Jones algorithm in Google Scholar]&lt;/ref&gt;

Implementing the Viola–Jones Face Detection Algorithm by Ole Helvig Jensen&lt;ref&gt;[http://etd.dtu.dk/thesis/223656/ep08_93.pdf Implementing Viola–Jones]&lt;/ref&gt;

Adaboost Explanation from ppt by Qing Chen, Discovery Labs, University of Ottawa and a video lecture by Ramsri Goutham.

Video link - &lt;ref&gt;[https://www.youtube.com/watch?v=WfdYYNamHZ8 Video lecture on Viola–Jones algorithm]&lt;/ref&gt;

== References ==
&lt;references/&gt;

== External links ==
* [http://www.mathworks.com/matlabcentral/fileexchange/29437-viola-jones-object-detection MATLAB implementation Viola–Jones detection]
* [http://www.slideshare.net/wolf/avihu-efrats-viola-and-jones-face-detection-slides/ Slides Presenting the Framework]
* [http://mathworld.wolfram.com/HaarFunction.html Information Regarding Haar Basis Functions]
* [https://sites.google.com/site/leeplus/publications/learningsurfcascadeforfastandaccurateobjectdetection Extension of Viola–Jones framework using SURF feature]
* [http://www.burgsys.com/mumi-image-mining-community.php IMMI - Rapidminer Image Mining Extension] - open-source tool for image mining
* [[Wikipedia:WikiProject Computer Vision]]
* [http://www.vision.caltech.edu/html-files/EE148-2005-Spring/pprs/viola04ijcv.pdf Robust Real-Time Face Detection]

{{DEFAULTSORT:Viola-Jones object detection framework}}
[[Category:Object recognition and categorization]]
[[Category:Face recognition]]
[[Category:Articles with example code]]
[[Category:Articles with example MATLAB/Octave code]]
[[Category:Articles with example pseudocode]]
[[Category:Gesture recognition]]
[[Category:Computer science]]</text>
      <sha1>o657exhgkri9cbyx94lu6u7qmi4jch4</sha1>
    </revision>
  </page>
  <page>
    <title>OpenCV</title>
    <ns>0</ns>
    <id>2056516</id>
    <revision>
      <id>771906764</id>
      <parentid>769660987</parentid>
      <timestamp>2017-03-24T05:06:09Z</timestamp>
      <contributor>
        <username>Julthep</username>
        <id>867131</id>
      </contributor>
      <comment>/* External links */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9670">{{primary sources|date=November 2012}}
{{Infobox software
| name                   =OpenCV 
| title                  = 
| logo                   = [[Image:OpenCV Logo with text svg version.svg|180px]]&lt;!-- Image name is enough --&gt;
| logo caption           = 
| logo size              = 
| logo alt               = 
| screenshot             = &lt;!-- Image name is enough --&gt;
| caption                = 
| screenshot size        = 
| screenshot alt         = 
| collapsible            = 
| author                 = [[Intel Corporation]], [[Willow Garage]], Itseez&lt;ref name=Itseez&gt;Itseez leads the development of the renowned computer vision library OpenCV. http://itseez.com&lt;/ref&gt;
| developer              = 
| released               = {{Start date and age|2000|06}}
| discontinued           = 
| latest release version = 3.2
| latest release date    = {{Start date and age|2016|12|23|df=yes/no}}
| latest preview version = 3.0.0 Beta
| latest preview date    = {{Start date and age|2014|11|11|df=yes/no}}
| status                 = 
| programming language   = [[C (programming language)|C]]/[[C++]]
| operating system       = [[Cross-platform]]
| platform               = 
| size                   = ~200 MB &lt;!-- 2.4.13 for Linux, unpacked --&gt;
| language               = 
| language count         = &lt;!-- Number only --&gt;
| language footnote      = 
| genre                  = Library
| license                = [[BSD license]]
| alexa                  = 
| website                = {{URL|opencv.org}},&lt;br /&gt;{{URL|https://github.com/Itseez/opencv}}
| standard               = 
| AsOf                   = 
}}
'''OpenCV''' (''Open Source Computer Vision'') is a [[library (computing)|library of programming functions]] mainly aimed at real-time [[computer vision]].&lt;ref&gt;{{cite web|last1=Pulli|first1=Kari|last2=Baksheev|first2=Anatoly|last3=Kornyakov|first3=Kirill|last4=Eruhimov|first4=Victor|title=Realtime Computer Vision with OpenCV|url=http://dl.acm.org/citation.cfm?id=2206309|website=Queue|pages=40:40–40:56|doi=10.1145/2181796.2206309|date=1 April 2012}}&lt;/ref&gt; Originally developed by [[Intel Corporation|Intel]]'s research center in [[Nizhny Novgorod]] (Russia), it was later supported by [[Willow Garage]] and is now maintained by Itseez.&lt;ref name=Itseez/&gt; The library is [[cross-platform]] and free for use under the [[open-source]] [[BSD license]].

==History==
Officially launched in 1999, the OpenCV project was initially an [[Intel Research Lablets|Intel Research]] initiative to advance [[central processing unit|CPU]]-intensive applications, part of a series of projects including [[Real-time computing|real-time]] [[ray tracing (graphics)|ray tracing]] and [[3D Display|3D display]] walls. The main contributors to the project included a number of optimization experts in Intel Russia, as well as Intel’s Performance Library Team. In the early days of OpenCV, the goals of the project were described&lt;ref&gt;{{cite book
 | last = Bradski
 | first = Gary
 | last2 = Kaehler
 | first2 = Adrian
 | authorlink =
 | title = Learning OpenCV: Computer vision with the OpenCV library
 | publisher = O'Reilly Media, Inc.
 | series =
 | volume =
 | edition =
 | date = 2008
 | location =
 | pages = 6
 | language =
 | url =
 | doi =
 | id =
 | isbn =
 | mr =
 | zbl =
 | jfm = }}&lt;/ref&gt; as:
&lt;blockquote&gt;
* Advance vision research by providing not only open but also [[Code optimization|optimized code]] for basic vision infrastructure. No more [[reinventing the wheel]].
* Disseminate vision knowledge by providing a common infrastructure that developers could build on, so that code would be more readily readable and transferable.
*Advance vision-based commercial applications by making [[Portability (computer science)|portable]], performance-optimized code available for free—with a license that did not require code to be open or free itself.
&lt;/blockquote&gt;

The first alpha version of OpenCV was released to the public at the [[Conference on Computer Vision and Pattern Recognition|IEEE Conference on Computer Vision and Pattern Recognition]] in 2000, and five betas were released between 2001 and 2005. The first 1.0 version was released in 2006. In mid-2008, OpenCV obtained corporate support from [[Willow Garage]], and is now again under active development. A version 1.1 &quot;pre-release&quot; was released in October 2008.

The second major release of the OpenCV was in October 2009. OpenCV 2 includes major changes to the [[C++]] interface, aiming at easier, more type-safe patterns, new functions, and better implementations for existing ones in terms of performance (especially on multi-core systems). Official releases now occur every six months&lt;ref&gt;OpenCV change logs: http://code.opencv.org/projects/opencv/wiki/ChangeLog&lt;/ref&gt; and development is now done by an independent Russian team supported by commercial corporations.

In August 2012, support for OpenCV was taken over by a non-profit foundation OpenCV.org, which maintains a developer&lt;ref&gt;OpenCV Developer Site: http://code.opencv.org&lt;/ref&gt; and user site.&lt;ref&gt;OpenCV User Site: http://opencv.org/&lt;/ref&gt;

== Applications ==
[[Image:OfxOpenCV.png|thumb|right|[[openFrameworks]] running the OpenCV add-on example]]
OpenCV's application areas include:

* 2D and 3D feature toolkits
* [[Egomotion]] estimation
* [[Facial recognition system]]
* [[Gesture recognition]]
* [[Human–computer interaction]] (HCI)
* [[Mobile robotics]]
* [[Motion understanding]]
* [[Object identification]]
* [[Segmentation (image processing)|Segmentation]] and recognition
* [[Stereopsis]] stereo vision: depth perception from 2 cameras
* [[Structure from motion]] (SFM)
* [[Video tracking|Motion tracking]]
* [[Augmented reality]]

To support some of the above areas, OpenCV includes a statistical [[machine learning]] library that contains:

* [[Boosting (meta-algorithm)|Boosting]]
* [[Decision tree learning]]
* [[Gradient boosting]] trees
* [[Expectation-maximization algorithm]]
* [[k-nearest neighbor algorithm]]
* [[Naive Bayes classifier]]
* [[Artificial neural network]]s
* [[Random forest]]
* [[Support vector machine]] (SVM)

==Programming language==
OpenCV is written in [[C++]] and its primary interface is in C++, but it still retains a less comprehensive though extensive older [[C (programming language)|C interface]]. There are bindings in [[Python (programming language)|Python]], [[Java (programming language)|Java]] and [[MATLAB]]/[[GNU Octave|OCTAVE]]. The API for these interfaces can be found in the online documentation.&lt;ref name=Cdocs&gt;OpenCV C interface: http://docs.opencv.org&lt;/ref&gt; Wrappers in other languages such as [[C Sharp (programming language)|C#]], [[Perl]],&lt;ref&gt;CPAN: http://search.cpan.org/~yuta/Cv-0.29/&lt;/ref&gt; [[Ch (computer programming)|Ch]],&lt;ref&gt;Ch OpenCV: http://www.softintegration.com/products/thirdparty/opencv/&lt;/ref&gt; [[Haskell (programming language)|Haskell]]&lt;ref&gt;The haskell-opencv project on Github: https://github.com/LumiGuide/haskell-opencv&lt;/ref&gt; and [[Ruby (programming language)|Ruby]] have been developed to encourage adoption by a wider audience.

All of the new developments and algorithms in OpenCV are now developed in the C++ interface.

==Hardware acceleration==

If the library finds Intel's [[Integrated Performance Primitives]] on the system, it will use these proprietary optimized routines to accelerate itself.

A [[CUDA]]-based [[graphics processing unit|GPU]] interface has been in progress since September 2010.&lt;ref name=OpenCVGPU&gt;Cuda GPU port: http://opencv.org/platforms/cuda.html&lt;/ref&gt;

An [[OpenCL]]-based [[graphics processing unit|GPU]] interface has been in progress since October 2012,&lt;ref name=OpenCVOCL&gt;OpenCL Announcement: http://opencv.org/opencv-v2-4-3rc-is-under-way.html&lt;/ref&gt; documentation for version 2.4.9.0 can be found at docs.opencv.org.&lt;ref name=OpenCVOCL2.4.5&gt;OpenCL-accelerated Computer Vision API Reference: http://docs.opencv.org/modules/ocl/doc/ocl.html&lt;/ref&gt;

== OS support ==
OpenCV runs on a variety of platforms. Desktop: [[Microsoft Windows|Windows]], [[Linux]], [[macOS]], [[FreeBSD]], [[NetBSD]], [[OpenBSD]]; Mobile: [[Android (operating system)|Android]], [[iOS]], [[Maemo]],&lt;ref name=Maemo_Port&gt;Maemo port: https://garage.maemo.org/projects/opencv&lt;/ref&gt; [[BlackBerry 10]].&lt;ref&gt;BlackBerry 10 (partial port): https://github.com/blackberry/OpenCV&lt;/ref&gt; The user can get official releases from [[SourceForge]] or take the latest sources from [[GitHub]].&lt;ref&gt;https://github.com/Itseez/opencv&lt;/ref&gt; OpenCV uses [[CMake]].

==See also==
{{Portal|Free software}}
* [[AForge.NET]], a computer vision library for the [[Common Language Runtime]] ([[.NET Framework]] and [[Mono (software)|Mono]]).
* [[ROS (Robot Operating System)]]. OpenCV is used as the primary vision package in ROS.
* [[VXL]], an alternative library written in C++.
* [[Integrating Vision Toolkit]] (IVT), a fast and easy-to-use C++ library with an optional interface to OpenCV.
* [[CVIPtools]], a complete GUI-based computer-vision and image-processing software environment, with C function libraries, a COM-based DLL, along with two utility programs for algorithm development and batch processing.
* [[OpenNN]], an open-source [[artificial neural network|neural networks]] library written in C++.

==References==
{{reflist}}

== External links ==
* {{GitHub|opencv/opencv}}
* {{sourceforge|opencvlibrary}}
* [http://docs.opencv.org/ Documentation of OpenCV]
* [http://www.cs.iit.edu/~agam/cs512/lect-notes/opencv-intro/opencv-intro.html Introduction to programming with OpenCV]

{{Image processing software}}

{{DEFAULTSORT:Opencv}}
[[Category:Computer vision software]]
[[Category:C++ libraries]]
[[Category:Gesture recognition]]
[[Category:Computer science]]</text>
      <sha1>plk7kob664b2hira74046pkvgo9n1zm</sha1>
    </revision>
  </page>
  <page>
    <title>Reduction Operator</title>
    <ns>0</ns>
    <id>51669182</id>
    <revision>
      <id>771879218</id>
      <parentid>770502567</parentid>
      <timestamp>2017-03-24T01:09:54Z</timestamp>
      <contributor>
        <username>JL-Bot</username>
        <id>4773966</id>
      </contributor>
      <minor/>
      <comment>removing stale construction template as last edited 8 days ago</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6635">In [[computer science]], the '''reduction operator'''&lt;ref&gt;Reduction Clause&lt;/ref&gt; is a special type of [[Operator (computer programming) |operator]] that is both [[Associative property |associative]] and [[Commutative property |commutative]]. &lt;ref name=&quot;:1&quot;&gt; Solihin &lt;/ref&gt;&lt;ref name=&quot;:0&quot;&gt;Chandra p. 59&lt;/ref&gt;&lt;ref&gt;{{Cite journal|last=Cole|first=Murray|year=2004|title=Bringing skeletons out of the closet: a pragmatic manifesto for skeletal parallel programming|journal=Parallel computing|volume=30|page=393}}&lt;/ref&gt; This type of operator is commonly used in [[Parallel computing |parallel programming]] to reduce the elements of an array into a single result. 

==Background==
In shared memory parallel programming, the main criteria is to have parallel threads in the program. In order to run sections in parallel, they shouldn't have a dependence relationship, as sections with dependence relationships cannot run in parallel. If there's a [[Read–write_conflict | R/W Conflicting]] dependence in variable reduction, an operation can be performed to remove the dependency and to make private copies of the variable. 

A reduction operator can help break down a task into various partial tasks by calculating partial results which can be used to obtain a final result. It allows certain serial operations to be performed in parallel, thereby reducing the number of steps required for certain operations. A reduction operator breaks a serial task into various partial tasks and stores the result into a private copy of the variable. These private copies are then merged into a shared copy at the end. 

An operator can be a reduction operator if:
* It can reduce an array into a single scalar value.&lt;ref name=&quot;:1&quot; /&gt; (Refer to example below)
* The final result obtained should be from the partial tasks that were created.&lt;ref name=&quot;:1&quot; /&gt;
These two requirements are satisfied for elements if the operations performed are &quot;Commutative&quot; and &quot;Associative&quot; (See the examples section). 

These properties are described as:
* [[Commutative_property | Commutative]]: An operator is commutative if it satisfies the condition:
''a ° b = b ° a''
* [[Associative_property | Associative]]: An operator is associative if it satisfies the condition:
''(a ° b) ° c = a ° (b ° c)''

Some operators which satisfy this are sum (addition), product (multiplication), and logical operators (and, or, etc.). An [[OpenMP|OpenMP]] user can specify the reduction operator and the variable being reduced using the ''reduction'' clause.&lt;ref name=&quot;:0&quot; /&gt; If an operator is not in OpenMP, the code will need to be modified and the operator should be expressed as a reduction operator. 

Reduction helps to remove the [[Data dependency|data dependencies]] in the section and can allow multiple threads to run at the same time thus parallelizing the task.

==Examples==

=== Addition ===
Suppose we have an array &lt;math&gt;[5, 7, 1, 4, 6, 8, 2, 3]&lt;/math&gt;. The sum of this array can be computed serially by sequentially reducing the array into a single sum using the '+' operator. Starting the summation from the beginning of the array yields:

&lt;math&gt;((((((5 + 7) + 1) + 4) + 6) + 8) + 2) + 3 = 36&lt;/math&gt;

Since '+' is both commutative and associative, it is a reduction operator. Therefore this reduction can be performed in parallel using several cores, where each core computes the sum of a subset of the array, and the reduction operator merges the results. Using a [[binary tree]] reduction would allow 4 cores to compute &lt;math&gt;(5 + 7)&lt;/math&gt;, &lt;math&gt;(1 + 4)&lt;/math&gt;, &lt;math&gt;(6 + 8)&lt;/math&gt;, and &lt;math&gt;(2 + 3)&lt;/math&gt;. Then two cores can compute &lt;math&gt;(12 + 5)&lt;/math&gt; and &lt;math&gt;(14 + 5)&lt;/math&gt;, and lastly a single core computes &lt;math&gt;(17 + 19) = 36&lt;/math&gt;. So a total of 4 cores can be used to compute the sum in &lt;math&gt;\log_{2}8 = 3&lt;/math&gt; steps instead of the &lt;math&gt;7&lt;/math&gt; steps required for the serial version. This parallel binary tree technique computes &lt;math&gt;((5 + 7) + (1 + 4)) + ((6 + 8) + (2 + 3))&lt;/math&gt;. Of course the result is the same, but only because of the associativity of the reduction operator. The commutativity of the reduction operator would be important if there were a master core distributing work to several processors, since then the results could arrive back to the master processor in any order. The property of commutativity guarantees that the result will be the same.

The pseudo-code for a basic binary tree parallel reduction algorithm is shown here:&lt;syntaxhighlight lang=&quot;c++&quot;&gt;
//Note: length must be a power of 2
int parallel_sum(int * array, int length) {
    int my_rank = get_rank();
    int num_values = length;
    int shift = 1;
    while(num_values != 1) {
        if(my_rank % shift == 0) {
            array[2 * my_rank] += array[2 * my_rank + shift];
        }
        shift = 2 * shift;
        num_values = num_values / 2;
        BARRIER();
    }
    if(my_rank == 0) {
        printf(&quot;Sum = %d\n&quot;, array[0]);
    }
}

int array[] = {5,7,1,4,6,8,2,3};
//launch 4 threads to execute the parallel_sum function
//with array and 8 as parameters:
launch_threads(8/2, parallel_sum, array, 8);

&lt;/syntaxhighlight&gt;Note that this algorithm stores the partial sums by overwriting portions of the original array, and the final result is found in the first element. 

=== Multiplication ===
Real number [[multiplication]] (&lt;math&gt;\times&lt;/math&gt;) is also a reduction operator since it is both associative and commutative. Thus a similar procedure as shown for addition can be performed in order to find the product of every element of a numeric array in parallel. 

== Nonexample ==

=== Matrix Multiplication ===
[[Matrix multiplication]] is '''not''' a reduction operator since the operation is not commutative. If processes were allowed to return their matrix multiplication results in any order to the master process, the final result that the master computes will likely be incorrect if the results arrived out of order. However, note that matrix multiplication is associative, and therefore the result would be correct as long as the proper ordering were enforced, as in the binary tree reduction technique.

==References==
{{Reflist}}

==Books==

*{{cite book|last1=Chandra|first1=Rohit|title=Parallel Programming in OpenMP|date=2001|publisher=Morgan Kaufmann|isbn=1558606718|pages=59–77}}

*{{cite book|last1=Solihin|first1=Yan|title=Fundamentals of Parallel Multicore Architecture|date=2016|publisher=CRC Press|isbn=978-1-4822-1118-4|page=75}}

==External links == 
*[https://www.dartmouth.edu/~rc/classes/intro_openmp/reduction_clause.html Reduction Clause], Reference to reduction clause

[[Category:Computer science]]</text>
      <sha1>ei1ih66el3y16j19z41g7zyx1q4ycgq</sha1>
    </revision>
  </page>
</mediawiki>
